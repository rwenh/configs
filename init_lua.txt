-- =====================================================
-- NEOVIM IDE CONFIGURATION v6.1 (OPTIMIZED)
-- Full-Featured IDE: Fortran, Python, Rust, SQL, VHDL, HTML, CSS, JS, Java
-- Platform: openSUSE Leap + KDE Plasma
-- Compatible: Neovim 0.9.5+
-- =====================================================

-- =====================================================
-- 1. CORE SYSTEM INITIALIZATION
-- =====================================================

-- Lua module cache for faster startup
if vim.loader and vim.fn.has('nvim-0.9') == 1 then
  vim.loader.enable()
end

-- Global configuration state
_G.nvim_ide = {
  debug_mode = vim.env.NVIM_DEBUG == "1",
  startup_time = vim.uv.hrtime(),
  failed_modules = {},
  security_mode = vim.env.NVIM_SECURITY == "1", -- Enable via export NVIM_SECURITY=1
  session_id = tostring(math.random(100000, 999999)),
  memory_limit_mb = os.getenv("NVIM_PROFILE") == "low" and 512 or 1024,
  initialized = false,
  language_servers = {},
  dap_adapters = {},
  solarized_variant = "original",
  project_root = nil,
  os_type = vim.uv.os_uname().sysname,
}

-- Cross-platform utilities
local function safe_path_join(...)
  local parts = {...}
  if vim.fs and vim.fs.joinpath then
    return vim.fs.joinpath(unpack(parts))
  else
    return table.concat(parts, vim.fn.has('win32') == 1 and '\\' or '/')
  end
end

-- Enhanced logging system
local log_file = safe_path_join(vim.fn.stdpath("log"), "nvim_ide.log")
local log_levels = { ERROR = 1, WARN = 2, INFO = 3, DEBUG = 4 }

local function log(message, level, opts)
  opts = opts or {}
  level = level or log_levels.INFO

  local should_log = level <= log_levels.WARN or _G.nvim_ide.debug_mode
  if not should_log then return end

  if level == log_levels.ERROR then
    local log_entry = string.format("[%s] ERROR: %s\n",
      os.date("%Y-%m-%d %H:%M:%S"), tostring(message))
    local file = io.open(log_file, "a")
    if file then
      file:write(log_entry)
      file:close()
    end
  end

  vim.schedule(function()
    local vim_level = level == log_levels.ERROR and vim.log.levels.ERROR or
                     level == log_levels.WARN and vim.log.levels.WARN or
                     vim.log.levels.INFO

    vim.notify(tostring(message), vim_level, {
      title = "Neovim IDE",
      timeout = level == log_levels.ERROR and 5000 or 2000
    })
  end)
end

-- Safe module loader with caching
local module_cache = {}
local function safe_require(module, opts)
  opts = opts or {}

  if module_cache[module] then
    return module_cache[module]
  end

  local ok, result = pcall(require, module)
  if ok then
    module_cache[module] = result
    return result
  end

  _G.nvim_ide.failed_modules[module] = {
    error = tostring(result),
    timestamp = os.time()
  }

  if opts.fallback then
    return opts.fallback
  end

  if not opts.silent then
    log("Module '" .. module .. "' failed to load: " .. tostring(result), log_levels.WARN)
  end
  return nil
end

-- Memory monitoring with action
local function check_memory()
  local memory_kb = collectgarbage("count")
  local memory_mb = memory_kb / 1024

  if memory_mb > _G.nvim_ide.memory_limit_mb then
    log(string.format("Memory usage high: %.1fMB - Running GC", memory_mb), log_levels.WARN)
    collectgarbage("collect")
    
    -- Clear module cache if still high
    local new_memory = collectgarbage("count") / 1024
    if new_memory > _G.nvim_ide.memory_limit_mb * 0.9 then
      module_cache = {}
      collectgarbage("collect")
      log("Cleared module cache due to high memory", log_levels.WARN)
    end
    return false
  end
  return true
end

-- =====================================================
-- 2. SECURITY HARDENING (OPTIONAL)
-- =====================================================

-- FIXED: Only enable security mode if explicitly requested
if _G.nvim_ide.security_mode then
  -- Note: These providers are needed for Mason and LSP
  -- Only disable if you don't need external language servers
  
  -- Disable unnecessary builtin plugins
  for _, plugin in ipairs({
    "gzip", "tar", "tarPlugin", "zip", "zipPlugin",
    "getscript", "getscriptPlugin", "vimball", "vimballPlugin",
    "2html_plugin", "logipat", "rrhelper", "spellfile_plugin",
    "netrw", "netrwPlugin", "netrwSettings", "netrwFileHandlers"
  }) do
    vim.g["loaded_" .. plugin] = 1
  end

  -- Security settings
  vim.opt.modeline = false
  vim.opt.exrc = false
  vim.opt.secure = true
end

-- =====================================================
-- 3. CORE VIM SETTINGS
-- =====================================================

-- Leader keys
vim.g.mapleader = " "
vim.g.maplocalleader = ","

-- UI Configuration
vim.opt.termguicolors = true
vim.opt.number = true
vim.opt.relativenumber = true
vim.opt.cursorline = true
vim.opt.cursorcolumn = false
vim.opt.signcolumn = "yes:2"
vim.opt.wrap = false
vim.opt.scrolloff = 8
vim.opt.sidescrolloff = 8
vim.opt.colorcolumn = "80,100,120"
vim.opt.conceallevel = 0

-- Indentation
vim.opt.tabstop = 4
vim.opt.shiftwidth = 4
vim.opt.softtabstop = 4
vim.opt.expandtab = true
vim.opt.smartindent = true
vim.opt.autoindent = true

-- Search and Navigation
vim.opt.ignorecase = true
vim.opt.smartcase = true
vim.opt.incsearch = true
vim.opt.hlsearch = true
vim.opt.wrapscan = true

-- Performance Optimization
vim.opt.updatetime = 300
vim.opt.timeoutlen = 500
vim.opt.ttimeoutlen = 10  -- OPTIMIZED: Reduced from 50
vim.opt.redrawtime = 10000
vim.opt.maxmempattern = 20000
vim.opt.lazyredraw = true  -- ADDED: Don't redraw during macros

-- File Handling
vim.opt.undofile = true
vim.opt.undolevels = 10000
vim.opt.backup = false
vim.opt.writebackup = false
vim.opt.swapfile = false
vim.opt.autowrite = true
vim.opt.autoread = true
vim.opt.confirm = true

-- Window Management
vim.opt.splitright = true
vim.opt.splitbelow = true
vim.opt.winminwidth = 5
vim.opt.winheight = 5
vim.opt.winminheight = 5

-- Completion
vim.opt.completeopt = { "menu", "menuone", "noselect", "noinsert" }
vim.opt.pumheight = 15
vim.opt.pumwidth = 25

-- Interface
vim.opt.mouse = "a"
vim.opt.clipboard = "unnamedplus"
vim.opt.laststatus = 3
vim.opt.cmdheight = 1
vim.opt.showmode = false
vim.opt.showcmd = true
vim.opt.ruler = true

-- Folding
vim.opt.foldmethod = "expr"
vim.opt.foldexpr = "nvim_treesitter#foldexpr()"
vim.opt.foldlevel = 20
vim.opt.foldlevelstart = 20

-- =====================================================
-- 4. PLUGIN MANAGER SETUP (LAZY.NVIM)
-- =====================================================

local lazypath = safe_path_join(vim.fn.stdpath("data"), "lazy", "lazy.nvim")

if not vim.uv.fs_stat(lazypath) then
  local out = vim.fn.system({
    "git", "clone", "--filter=blob:none",
    "https://github.com/folke/lazy.nvim.git",
    "--branch=stable", lazypath
  })

  if vim.v.shell_error ~= 0 then
    log("Failed to install lazy.nvim: " .. tostring(out), log_levels.ERROR)
    return
  end
end

vim.opt.rtp:prepend(lazypath)

-- =====================================================
-- 5. UTILITY FUNCTIONS
-- =====================================================

-- Safe plugin setup wrapper
local function setup_plugin(plugin_name, setup_fn)
  local plugin = safe_require(plugin_name, { silent = true })
  if not plugin then return false end

  local ok, err = pcall(setup_fn, plugin)
  if not ok then
    log("Failed to setup " .. plugin_name .. ": " .. tostring(err), log_levels.ERROR)
    return false
  end
  return true
end

-- Smart buffer management
local function smart_buf_delete()
  local buf = vim.api.nvim_get_current_buf()
  if vim.bo[buf].modified then
    local choice = vim.fn.confirm("Save changes?", "&Yes\n&No\n&Cancel", 1)
    if choice == 1 then
      vim.cmd("write")
    elseif choice == 3 then
      return
    end
  end

  local buffers = vim.fn.getbufinfo({buflisted = 1})
  if #buffers <= 1 then
    vim.cmd("enew")
  end

  vim.cmd("bdelete! " .. buf)
end

-- Enhanced project root detection (OPTIMIZED)
local root_cache = {}
local function find_project_root()
  local start = vim.fn.expand("%:p:h")
  
  -- Check cache
  if root_cache[start] then
    return root_cache[start]
  end
  
  local root_markers = {
    -- Version control (highest priority)
    ".git", ".hg", ".svn",
    -- Build systems
    "Makefile", "CMakeLists.txt", "build.gradle", "pom.xml",
    -- Language specific
    "package.json", "Cargo.toml", "go.mod", "pyproject.toml", 
    "setup.py", "requirements.txt", "Pipfile",
    -- IDE/Editor
    ".nvim.lua", ".vscode",
    -- Fortran/VHDL
    "configure.ac", "modelsim.ini",
  }

  local current = start
  local iterations = 0
  local max_iterations = 20  -- Prevent infinite loops

  while current ~= "/" and current ~= "" and iterations < max_iterations do
    for _, marker in ipairs(root_markers) do
      local path = safe_path_join(current, marker)
      if vim.fn.isdirectory(path) == 1 or vim.fn.filereadable(path) == 1 then
        root_cache[start] = current
        _G.nvim_ide.project_root = current
        return current
      end
    end
    current = vim.fn.fnamemodify(current, ":h")
    iterations = iterations + 1
  end

  local cwd = vim.fn.getcwd()
  root_cache[start] = cwd
  _G.nvim_ide.project_root = cwd
  return cwd
end

-- Language detection
local function get_language_context()
  local ft = vim.bo.filetype
  local filename = vim.fn.expand("%:t")

  return {
    filetype = ft,
    filename = filename,
    is_source_file = vim.tbl_contains({
      "python", "rust", "fortran", "sql", "vhdl", "html", "css",
      "javascript", "typescript", "java", "lua", "c", "cpp"
    }, ft),
    project_root = find_project_root(),
  }
end

-- ADDED: Check if command exists
local function command_exists(cmd)
  return vim.fn.executable(cmd) == 1
end

-- =====================================================
-- 6. AUTHENTIC SOLARIZED COLOR PALETTE
-- =====================================================

local solarized_colors = {
  -- Base tones
  base03  = "#002b36",
  base02  = "#073642",
  base01  = "#586e75",
  base00  = "#657b83",
  base0   = "#839496",
  base1   = "#93a1a1",
  base2   = "#eee8d5",
  base3   = "#fdf6e3",

  -- Accent colors
  yellow  = "#b58900",
  orange  = "#cb4b16",
  red     = "#dc322f",
  magenta = "#d33682",
  violet  = "#6c71c4",
  blue    = "#268bd2",
  cyan    = "#2aa198",
  green   = "#859900",
}

-- Color conversion utilities with validation
local function hex_to_rgb(hex)
  if type(hex) ~= "string" or not hex:match("^#%x%x%x%x%x%x$") then
    log("Invalid hex color: " .. tostring(hex), log_levels.WARN)
    return 0  -- Fallback to black
  end
  
  local r = tonumber(hex:sub(2, 3), 16)
  local g = tonumber(hex:sub(4, 5), 16)
  local b = tonumber(hex:sub(6, 7), 16)
  
  -- Validate ranges
  if not (r and g and b and r >= 0 and r <= 255 and g >= 0 and g <= 255 and b >= 0 and b <= 255) then
    log("Color conversion failed for: " .. hex, log_levels.WARN)
    return 0
  end
  
  return (r * 65536) + (g * 256) + b
end

-- Enhanced highlight definitions
local highlight_groups = {
  {
    groups = {
      "Function", "@function", "@function.call", "@function.builtin",
      "@method", "@method.call", "@constructor",
      "Type", "@type", "@type.builtin", "@type.definition",
      "Keyword", "@keyword", "@keyword.function", "@keyword.return",
      "@lsp.type.function", "@lsp.type.method", "@lsp.type.type",
      "@lsp.type.class", "@lsp.type.keyword",
    },
    opts = { fg = hex_to_rgb(solarized_colors.green), bold = false }
  },
  {
    groups = {
      "Constant", "@constant", "Number", "@number", "String", "@string",
      "@string.escape", "@character"
    },
    opts = { fg = hex_to_rgb(solarized_colors.cyan) }
  },
  {
    groups = { "Comment", "@comment", "@comment.todo", "@comment.note" },
    opts = { fg = hex_to_rgb(solarized_colors.base01), italic = true }
  },
  {
    groups = { "@variable", "@variable.parameter", "Identifier" },
    opts = { fg = hex_to_rgb(solarized_colors.base0) }
  },
  {
    groups = { "@variable.builtin", "Special" },
    opts = { fg = hex_to_rgb(solarized_colors.red) }
  },
  {
    groups = {
      "Operator", "@operator", "Delimiter",
      "@punctuation.delimiter", "@punctuation.bracket"
    },
    opts = { fg = hex_to_rgb(solarized_colors.base01) }
  },
  {
    groups = { "PreProc", "@preproc", "Include", "Define", "Macro" },
    opts = { fg = hex_to_rgb(solarized_colors.orange) }
  },
  {
    groups = { "pythonBuiltin", "rustKeyword", "fortranKeyword" },
    opts = { fg = hex_to_rgb(solarized_colors.violet) }
  },
}

-- UI-specific highlights
local ui_highlights = {
  NormalFloat = { bg = hex_to_rgb(solarized_colors.base02), fg = hex_to_rgb(solarized_colors.base0) },
  FloatBorder = { bg = hex_to_rgb(solarized_colors.base02), fg = hex_to_rgb(solarized_colors.base01) },
  Pmenu = { bg = hex_to_rgb(solarized_colors.base02), fg = hex_to_rgb(solarized_colors.base0) },
  PmenuSel = { bg = hex_to_rgb(solarized_colors.base01), fg = hex_to_rgb(solarized_colors.base2), bold = true },

  DiagnosticError = { fg = hex_to_rgb(solarized_colors.red) },
  DiagnosticWarn = { fg = hex_to_rgb(solarized_colors.yellow) },
  DiagnosticInfo = { fg = hex_to_rgb(solarized_colors.blue) },
  DiagnosticHint = { fg = hex_to_rgb(solarized_colors.cyan) },

  DapBreakpoint = { fg = hex_to_rgb(solarized_colors.red), bold = true },
  DapStopped = { fg = hex_to_rgb(solarized_colors.green), bold = true },

  TelescopeNormal = { bg = hex_to_rgb(solarized_colors.base03) },
  TelescopeSelection = { fg = hex_to_rgb(solarized_colors.base1), bg = hex_to_rgb(solarized_colors.base02) },

  NvimTreeNormal = { bg = hex_to_rgb(solarized_colors.base03) },
  NvimTreeDirectoryIcon = { fg = hex_to_rgb(solarized_colors.blue) },
}

-- Apply highlights function (OPTIMIZED: Single pass)
local function apply_solarized_highlights()
  for _, group_def in ipairs(highlight_groups) do
    for _, group in ipairs(group_def.groups) do
      vim.api.nvim_set_hl(0, group, group_def.opts)
    end
  end

  for group, opts in pairs(ui_highlights) do
    vim.api.nvim_set_hl(0, group, opts)
  end
end

-- =====================================================
-- 7. LANGUAGE SERVER CONFIGURATIONS
-- =====================================================

local function get_lsp_servers()
  return {
    pyright = {
      settings = {
        python = {
          analysis = {
            typeCheckingMode = "basic",
            autoSearchPaths = true,
            useLibraryCodeForTypes = true,
          }
        }
      }
    },

    rust_analyzer = {
      settings = {
        ['rust-analyzer'] = {
          cargo = { allFeatures = true },
          checkOnSave = { command = "clippy" },
        }
      }
    },

    fortls = {
      settings = {
        fortls = {
          nthreads = 2,
          incDirs = {"./include", "./src"},
          -- FIXED: Removed preprocessor define - configure per project via .fortls config
          -- Create .fortls in project root for custom settings
        }
      }
    },

    sqlls = {},

    vhdl_ls = {
      settings = {
        vhdl_ls = {
          project_file = ".vhdl_ls.toml"
        }
      }
    },

    html = {},
    cssls = {},
    ts_ls = {},

    jdtls = {
      cmd = { "jdtls" },
      root_dir = function(fname)
        local root = vim.fs.find({'.git', 'mvnw', 'gradlew', 'pom.xml', 'build.gradle'}, {
          path = fname,
          upward = true,
        })[1]
        -- FIXED: Return directory, not file path
        return root and vim.fn.fnamemodify(root, ":h") or vim.fn.getcwd()
      end,
    },

    lua_ls = {
      settings = {
        Lua = {
          runtime = { version = "LuaJIT" },
          diagnostics = {
            globals = { "vim", "_G", "nvim_ide" },
            disable = { "missing-fields" }
          },
          workspace = {
            checkThirdParty = false,
            library = vim.api.nvim_get_runtime_file("", true)
          },
          telemetry = { enable = false },
        },
      },
    },

    jsonls = {},
    yamlls = {},
    marksman = {},
  }
end

-- =====================================================
-- 8. PLUGIN SPECIFICATIONS
-- =====================================================

require("lazy").setup({
  -- ========== COLORSCHEME ==========
  {
    "maxmx03/solarized.nvim",
    lazy = false,
    priority = 1000,
    config = function()
      vim.o.termguicolors = true
      vim.o.background = "dark"

      local solarized = safe_require("solarized")
      if solarized then
        solarized.setup({
          transparent = { enabled = false },
          palette = "solarized",
          styles = {
            comments = { italic = true },
            keywords = { italic = false },
            functions = { bold = false },
            variables = {},
          },
          plugins = {
            treesitter = true, lspconfig = true, cmp = true,
            telescope = true, gitsigns = true, nvimtree = true,
          },
        })

        pcall(vim.cmd.colorscheme, "solarized")
        -- OPTIMIZED: Reduced delay from 100ms to 50ms
        vim.defer_fn(apply_solarized_highlights, 50)
      end
    end,
  },

  -- ========== LSP ECOSYSTEM ==========
  {
    "williamboman/mason.nvim",
    cmd = "Mason",
    build = ":MasonUpdate",
    config = function()
      setup_plugin("mason", function(mason)
        mason.setup({
          ui = {
            border = "rounded",
            icons = {
              package_installed = "✓",
              package_pending = "➜",
              package_uninstalled = "✗"
            }
          },
          max_concurrent_installers = 4,
        })
      end)
    end,
  },

  {
    "williamboman/mason-lspconfig.nvim",
    dependencies = { "mason.nvim" },
    event = { "BufReadPre", "BufNewFile" },
    config = function()
      setup_plugin("mason-lspconfig", function(mason_lspconfig)
        mason_lspconfig.setup({
          ensure_installed = {
            "lua_ls", "pyright", "rust_analyzer", "fortls",
            "sqlls", "vhdl_ls", "html", "cssls", "ts_ls",
            "jdtls", "jsonls", "yamlls", "marksman"
          },
          automatic_installation = true,
        })
      end)
    end,
  },

  {
    "neovim/nvim-lspconfig",
    dependencies = { "mason-lspconfig.nvim", "hrsh7th/cmp-nvim-lsp" },
    event = { "BufReadPre", "BufNewFile" },
    config = function()
      local lspconfig = safe_require("lspconfig")
      local cmp_nvim_lsp = safe_require("cmp_nvim_lsp")
      if not (lspconfig and cmp_nvim_lsp) then return end

      local capabilities = vim.tbl_deep_extend(
        "force", {},
        vim.lsp.protocol.make_client_capabilities(),
        cmp_nvim_lsp.default_capabilities()
      )

      local function on_attach(client, bufnr)
        local function map(mode, lhs, rhs, desc)
          vim.keymap.set(mode, lhs, rhs, { buffer = bufnr, desc = desc, silent = true })
        end

        map("n", "gD", vim.lsp.buf.declaration, "Go to declaration")
        map("n", "gd", vim.lsp.buf.definition, "Go to definition")
        map("n", "gi", vim.lsp.buf.implementation, "Go to implementation")
        map("n", "gr", vim.lsp.buf.references, "Go to references")
        map("n", "gt", vim.lsp.buf.type_definition, "Go to type definition")

        map("n", "K", vim.lsp.buf.hover, "Hover documentation")
        map("n", "<C-k>", vim.lsp.buf.signature_help, "Signature help")
        map("i", "<C-k>", vim.lsp.buf.signature_help, "Signature help")

        map("n", "<leader>ca", vim.lsp.buf.code_action, "Code action")
        map("v", "<leader>ca", vim.lsp.buf.code_action, "Code action")
        map("n", "<leader>rn", vim.lsp.buf.rename, "Rename symbol")

        map("n", "<leader>cf", function()
          vim.lsp.buf.format({ async = true })
        end, "Format buffer")
        map("v", "<leader>cf", function()
          vim.lsp.buf.format({ async = true })
        end, "Format selection")

        map("n", "<leader>wa", vim.lsp.buf.add_workspace_folder, "Add workspace folder")
        map("n", "<leader>wr", vim.lsp.buf.remove_workspace_folder, "Remove workspace folder")
        map("n", "<leader>wl", function()
          print(vim.inspect(vim.lsp.buf.list_workspace_folders()))
        end, "List workspace folders")

        if client.server_capabilities.documentHighlightProvider then
          local group = vim.api.nvim_create_augroup("LSPDocumentHighlight", { clear = false })
          vim.api.nvim_create_autocmd({ "CursorHold", "CursorHoldI" }, {
            buffer = bufnr,
            group = group,
            callback = vim.lsp.buf.document_highlight,
          })
          vim.api.nvim_create_autocmd("CursorMoved", {
            buffer = bufnr,
            group = group,
            callback = vim.lsp.buf.clear_references,
          })
        end

        if client.server_capabilities.inlayHintProvider then
          map("n", "<leader>th", function()
            vim.lsp.inlay_hint.enable(not vim.lsp.inlay_hint.is_enabled())
          end, "Toggle inlay hints")
        end
      end

      local servers = get_lsp_servers()
      for server, config in pairs(servers) do
        if lspconfig[server] then
          lspconfig[server].setup(vim.tbl_extend("force", {
            capabilities = capabilities,
            on_attach = on_attach,
          }, config))
          _G.nvim_ide.language_servers[server] = true
        end
      end

      vim.diagnostic.config({
        virtual_text = {
          prefix = "●",
          source = "if_many",
          spacing = 2,
        },
        float = {
          border = "rounded",
          source = "always",
          header = "",
          prefix = "",
        },
        signs = true,
        underline = true,
        update_in_insert = false,
        severity_sort = true,
      })

      local signs = { Error = " ", Warn = " ", Hint = " ", Info = " " }
      for type, icon in pairs(signs) do
        local hl = "DiagnosticSign" .. type
        vim.fn.sign_define(hl, { text = icon, texthl = hl, numhl = hl })
      end
    end,
  },

  -- ========== COMPLETION SYSTEM ==========
  {
    "hrsh7th/nvim-cmp",
    event = { "InsertEnter", "CmdlineEnter" },
    dependencies = {
      "hrsh7th/cmp-nvim-lsp",
      "hrsh7th/cmp-buffer",
      "hrsh7th/cmp-path",
      "hrsh7th/cmp-cmdline",
      "hrsh7th/cmp-nvim-lsp-signature-help",
      {
        "L3MON4D3/LuaSnip",
        version = "v2.*",
        build = "make install_jsregexp",
        dependencies = { "rafamadriz/friendly-snippets" },
      },
      "saadparwaiz1/cmp_luasnip",
      "onsails/lspkind.nvim",
    },
    config = function()
      setup_plugin("cmp", function(cmp)
        local luasnip = safe_require("luasnip")
        local lspkind = safe_require("lspkind")

        if not (luasnip and lspkind) then return end

        require("luasnip.loaders.from_vscode").lazy_load()

        cmp.setup({
          snippet = {
            expand = function(args)
              luasnip.lsp_expand(args.body)
            end,
          },

          mapping = cmp.mapping.preset.insert({
            ["<C-b>"] = cmp.mapping.scroll_docs(-4),
            ["<C-f>"] = cmp.mapping.scroll_docs(4),
            ["<C-Space>"] = cmp.mapping.complete(),
            ["<C-e>"] = cmp.mapping.abort(),
            ["<CR>"] = cmp.mapping.confirm({ select = false }),

            ["<Tab>"] = cmp.mapping(function(fallback)
              if cmp.visible() then
                cmp.select_next_item()
              elseif luasnip.expand_or_locally_jumpable() then
                luasnip.expand_or_jump()
              else
                fallback()
              end
            end, { "i", "s" }),

            ["<S-Tab>"] = cmp.mapping(function(fallback)
              if cmp.visible() then
                cmp.select_prev_item()
              elseif luasnip.locally_jumpable(-1) then
                luasnip.jump(-1)
              else
                fallback()
              end
            end, { "i", "s" }),
          }),

          formatting = {
            format = lspkind.cmp_format({
              mode = "symbol_text",
              maxwidth = 50,
              ellipsis_char = "...",
              symbol_map = {
                Text = "󰉿", Method = "󰆧", Function = "󰊕", Constructor = "",
                Field = "󰜢", Variable = "󰀫", Class = "󰠱", Interface = "",
                Module = "", Property = "󰜢", Unit = "󰑭",
                Value = "󰎠", Enum = "", Keyword = "󰌋", Snippet = "",
                Color = "󰏘", File = "󰈙", Reference = "󰈇", Folder = "󰉋",
                EnumMember = "", Constant = "󰏿", Struct = "󰙅",
                Event = "", Operator = "󰆕", TypeParameter = "",
              },
            }),
          },

          sources = cmp.config.sources({
            { name = "nvim_lsp", priority = 1000 },
            { name = "nvim_lsp_signature_help", priority = 900 },
            { name = "luasnip", priority = 800 },
          }, {
            { name = "buffer", keyword_length = 3, priority = 500 },
            { name = "path", priority = 400 },
          }),

          window = {
            completion = cmp.config.window.bordered({
              border = "rounded",
              winhighlight = "Normal:NormalFloat,FloatBorder:FloatBorder,CursorLine:PmenuSel,Search:None",
            }),
            documentation = cmp.config.window.bordered({
              border = "rounded",
              winhighlight = "Normal:NormalFloat,FloatBorder:FloatBorder,CursorLine:PmenuSel,Search:None",
            }),
          },

          experimental = {
            ghost_text = true,
          },
        })

        cmp.setup.cmdline({ "/", "?" }, {
          mapping = cmp.mapping.preset.cmdline(),
          sources = { { name = "buffer" } },
        })

        cmp.setup.cmdline(":", {
          mapping = cmp.mapping.preset.cmdline(),
          sources = cmp.config.sources(
            { { name = "path" } },
            { { name = "cmdline" } }
          ),
        })
      end)
    end,
  },

  -- ========== SYNTAX HIGHLIGHTING ==========
  {
    "nvim-treesitter/nvim-treesitter",
    build = ":TSUpdate",
    event = { "BufReadPost", "BufNewFile" },
    dependencies = {
      "nvim-treesitter/nvim-treesitter-textobjects",
      "nvim-treesitter/nvim-treesitter-context",
    },
    config = function()
      setup_plugin("nvim-treesitter.configs", function(configs)
        configs.setup({
          ensure_installed = {
            "c", "lua", "vim", "vimdoc", "query", "markdown", "markdown_inline",
            "python", "rust", "fortran", "sql", "html", "css",
            "javascript", "typescript", "java", "json", "yaml", "toml",
            "bash", "dockerfile", "git_config", "gitignore"
            -- NOTE: VHDL parser not available in official tree-sitter
            -- Install manually if needed: https://github.com/alemuller/tree-sitter-vhdl
          },

          auto_install = true,
          sync_install = false,

          highlight = {
            enable = true,
            disable = function(lang, buf)
              local max_filesize = 100 * 1024
              local ok, stats = pcall(vim.uv.fs_stat, vim.api.nvim_buf_get_name(buf))
              if ok and stats and stats.size > max_filesize then
                return true
              end
            end,
            additional_vim_regex_highlighting = false,
          },

          indent = {
            enable = true,
            disable = { "python", "yaml" }
          },

          incremental_selection = {
            enable = true,
            keymaps = {
              init_selection = "<C-space>",
              node_incremental = "<C-space>",
              scope_incremental = "<C-s>",
              node_decremental = "<M-space>",
            },
          },

          textobjects = {
            select = {
              enable = true,
              lookahead = true,
              keymaps = {
                ["af"] = "@function.outer",
                ["if"] = "@function.inner",
                ["ac"] = "@class.outer",
                ["ic"] = "@class.inner",
                ["aa"] = "@parameter.outer",
                ["ia"] = "@parameter.inner",
                ["al"] = "@loop.outer",
                ["il"] = "@loop.inner",
                ["ai"] = "@conditional.outer",
                ["ii"] = "@conditional.inner",
              },
            },
            move = {
              enable = true,
              set_jumps = true,
              goto_next_start = {
                ["]m"] = "@function.outer",
                ["]]"] = "@class.outer",
              },
              goto_next_end = {
                ["]M"] = "@function.outer",
                ["]["] = "@class.outer",
              },
              goto_previous_start = {
                ["[m"] = "@function.outer",
                ["[["] = "@class.outer",
              },
              goto_previous_end = {
                ["[M"] = "@function.outer",
                ["[]"] = "@class.outer",
              },
            },
          },
        })
      end)

      setup_plugin("treesitter-context", function(context)
        context.setup({
          enable = true,
          max_lines = 4,
          min_window_height = 20,
          patterns = {
            default = {
              'class', 'function', 'method', 'for', 'while', 'if', 'switch', 'case',
            },
          },
        })
      end)
    end,
  },

  -- ========== FILE EXPLORER ==========
  {
    "nvim-tree/nvim-tree.lua",
    version = "*",
    lazy = false,
    dependencies = { "nvim-tree/nvim-web-devicons" },
    keys = {
      { "<leader>e", "<cmd>NvimTreeToggle<cr>", desc = "Toggle file explorer" },
      { "<leader>E", "<cmd>NvimTreeFindFile<cr>", desc = "Find current file in explorer" },
    },
    config = function()
      setup_plugin("nvim-tree", function(nvim_tree)
        nvim_tree.setup({
          sort_by = "case_sensitive",
          view = {
            width = 35,
            side = "left",
            preserve_window_proportions = true,
          },
          renderer = {
            group_empty = true,
            highlight_git = true,
            highlight_opened_files = "icon",
            indent_markers = {
              enable = true,
              inline_arrows = true,
              icons = {
                corner = "└",
                edge = "│",
                item = "│",
                none = " ",
              },
            },
            icons = {
              webdev_colors = true,
              git_placement = "before",
              padding = " ",
              symlink_arrow = " ➛ ",
              show = {
                file = true,
                folder = true,
                folder_arrow = true,
                git = true,
              },
              glyphs = {
                default = "",
                symlink = "",
                bookmark = "",
                folder = {
                  arrow_closed = "",
                  arrow_open = "",
                  default = "",
                  open = "",
                  empty = "",
                  empty_open = "",
                  symlink = "",
                  symlink_open = "",
                },
                git = {
                  unstaged = "✗",
                  staged = "✓",
                  unmerged = "",
                  renamed = "➜",
                  untracked = "★",
                  deleted = "",
                  ignored = "◌",
                },
              },
            },
          },
          filters = {
            dotfiles = false,
            custom = { "node_modules", ".cache" },
          },
          git = {
            enable = true,
            ignore = false,
            show_on_dirs = true,
            timeout = 400,
          },
          actions = {
            use_system_clipboard = true,
            change_dir = {
              enable = true,
              global = false,
              restrict_above_cwd = false,
            },
            open_file = {
              quit_on_open = false,
              resize_window = true,
              window_picker = {
                enable = true,
                picker = "default",
                chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890",
                exclude = {
                  filetype = { "notify", "packer", "qf", "diff", "fugitive", "fugitiveblame" },
                  buftype = { "nofile", "terminal", "help" },
                },
              },
            },
          },
          live_filter = {
            prefix = "[FILTER]: ",
            always_show_folders = true,
          },
        })
      end)
    end,
  },

  -- ========== FUZZY FINDER ==========
  {
    "nvim-telescope/telescope.nvim",
    tag = "0.1.8",
    cmd = "Telescope",
    keys = {
      { "<leader>ff", "<cmd>Telescope find_files<cr>", desc = "Find files" },
      { "<leader>fg", "<cmd>Telescope live_grep<cr>", desc = "Live grep" },
      { "<leader>fb", "<cmd>Telescope buffers<cr>", desc = "Find buffers" },
      { "<leader>fh", "<cmd>Telescope help_tags<cr>", desc = "Help tags" },
      { "<leader>fr", "<cmd>Telescope oldfiles<cr>", desc = "Recent files" },
      { "<leader>fc", "<cmd>Telescope commands<cr>", desc = "Commands" },
      { "<leader>fk", "<cmd>Telescope keymaps<cr>", desc = "Keymaps" },
      { "<leader>fs", "<cmd>Telescope lsp_document_symbols<cr>", desc = "Document symbols" },
      { "<leader>fS", "<cmd>Telescope lsp_workspace_symbols<cr>", desc = "Workspace symbols" },
      { "<leader>fd", "<cmd>Telescope diagnostics<cr>", desc = "Diagnostics" },
      { "<leader>fq", "<cmd>Telescope quickfix<cr>", desc = "Quickfix" },
      { "<leader>fl", "<cmd>Telescope loclist<cr>", desc = "Location list" },
      { "<C-p>", "<cmd>Telescope find_files<cr>", desc = "Find files" },
      { "<C-f>", "<cmd>Telescope live_grep<cr>", desc = "Live grep" },
    },
    dependencies = {
      "nvim-lua/plenary.nvim",
      { "nvim-telescope/telescope-fzf-native.nvim", build = "make" },
      "nvim-telescope/telescope-ui-select.nvim",
      "nvim-telescope/telescope-project.nvim",
    },
    config = function()
      setup_plugin("telescope", function(telescope)
        telescope.setup({
          defaults = {
            prompt_prefix = "   ",
            selection_caret = "  ",
            entry_prefix = "  ",
            initial_mode = "insert",
            selection_strategy = "reset",
            sorting_strategy = "ascending",
            layout_strategy = "horizontal",
            layout_config = {
              horizontal = {
                prompt_position = "top",
                preview_width = 0.55,
                results_width = 0.8,
              },
              vertical = {
                mirror = false,
              },
              width = 0.87,
              height = 0.80,
              preview_cutoff = 120,
            },
            file_sorter = require("telescope.sorters").get_fuzzy_file,
            file_ignore_patterns = {
              "node_modules", ".git/", "__pycache__/", "*.pyc",
              "*.jpg", "*.jpeg", "*.png", "*.gif", "*.zip", "*.tar", "*.gz",
              "target/", "build/", "dist/", ".cache/",
              "*.o", "*.so", "*.dll", "*.exe",
            },
            generic_sorter = require("telescope.sorters").get_generic_fuzzy_sorter,
            path_display = { "truncate" },
            winblend = 0,
            border = {},
            borderchars = { "─", "│", "─", "│", "╭", "╮", "╯", "╰" },
            color_devicons = true,
            use_less = true,
            set_env = { ["COLORTERM"] = "truecolor" },
            file_previewer = require("telescope.previewers").vim_buffer_cat.new,
            grep_previewer = require("telescope.previewers").vim_buffer_vimgrep.new,
            qflist_previewer = require("telescope.previewers").vim_buffer_qflist.new,
            buffer_previewer_maker = require("telescope.previewers").buffer_previewer_maker,
          },

          pickers = {
            find_files = {
              theme = "dropdown",
              previewer = false,
              hidden = true,
              find_command = { "rg", "--files", "--hidden", "--glob", "!**/.git/*" },
            },
            buffers = {
              theme = "dropdown",
              previewer = false,
              sort_lastused = true,
              sort_mru = true,
              mappings = {
                i = { ["<c-d>"] = "delete_buffer" },
                n = { ["dd"] = "delete_buffer" },
              },
            },
            oldfiles = {
              theme = "dropdown",
              previewer = false,
            },
            live_grep = {
              additional_args = function(opts)
                return {"--hidden"}
              end
            },
          },

          extensions = {
            fzf = {
              fuzzy = true,
              override_generic_sorter = true,
              override_file_sorter = true,
              case_mode = "smart_case",
            },
            ["ui-select"] = {
              require("telescope.themes").get_dropdown {}
            },
            project = {
              base_dirs = {
                '~/projects',
                '~/work',
              },
              hidden_files = true,
              theme = "dropdown",
            }
          },
        })

        pcall(telescope.load_extension, "fzf")
        pcall(telescope.load_extension, "ui-select")
        pcall(telescope.load_extension, "project")
      end)
    end,
  },

  -- ========== GIT INTEGRATION ==========
  {
    "lewis6991/gitsigns.nvim",
    event = { "BufReadPre", "BufNewFile" },
    config = function()
      setup_plugin("gitsigns", function(gitsigns)
        gitsigns.setup({
          signs = {
            add = { text = "+" },
            change = { text = "~" },
            delete = { text = "_" },
            topdelete = { text = "‾" },
            changedelete = { text = "~" },
            untracked = { text = "┆" },
          },
          signs_staged = {
            add = { text = "+" },
            change = { text = "~" },
            delete = { text = "_" },
            topdelete = { text = "‾" },
            changedelete = { text = "~" },
            untracked = { text = "┆" },
          },
          signs_staged_enable = true,
          signcolumn = true,
          numhl = false,
          linehl = false,
          word_diff = false,
          watch_gitdir = {
            follow_files = true
          },
          auto_attach = true,
          attach_to_untracked = false,
          current_line_blame = false,
          current_line_blame_opts = {
            virt_text = true,
            virt_text_pos = 'eol',
            delay = 1000,
            ignore_whitespace = false,
            virt_text_priority = 100,
          },
          current_line_blame_formatter = '<author>, <author_time:%Y-%m-%d> - <summary>',
          preview_config = {
            border = 'single',
            style = 'minimal',
            relative = 'cursor',
            row = 0,
            col = 1
          },
          on_attach = function(bufnr)
            local gs = package.loaded.gitsigns

            local function map(mode, l, r, opts)
              opts = opts or {}
              opts.buffer = bufnr
              vim.keymap.set(mode, l, r, opts)
            end

            map('n', ']c', function()
              if vim.wo.diff then return ']c' end
              vim.schedule(function() gs.next_hunk() end)
              return '<Ignore>'
            end, {expr=true, desc="Next hunk"})

            map('n', '[c', function()
              if vim.wo.diff then return '[c' end
              vim.schedule(function() gs.prev_hunk() end)
              return '<Ignore>'
            end, {expr=true, desc="Previous hunk"})

            map('n', '<leader>hs', gs.stage_hunk, {desc="Stage hunk"})
            map('n', '<leader>hr', gs.reset_hunk, {desc="Reset hunk"})
            map('v', '<leader>hs', function() gs.stage_hunk {vim.fn.line('.'), vim.fn.line('v')} end, {desc="Stage hunk"})
            map('v', '<leader>hr', function() gs.reset_hunk {vim.fn.line('.'), vim.fn.line('v')} end, {desc="Reset hunk"})
            map('n', '<leader>hS', gs.stage_buffer, {desc="Stage buffer"})
            map('n', '<leader>hu', gs.undo_stage_hunk, {desc="Undo stage hunk"})
            map('n', '<leader>hR', gs.reset_buffer, {desc="Reset buffer"})
            map('n', '<leader>hp', gs.preview_hunk, {desc="Preview hunk"})
            map('n', '<leader>hb', function() gs.blame_line{full=true} end, {desc="Blame line"})
            map('n', '<leader>tb', gs.toggle_current_line_blame, {desc="Toggle line blame"})
            map('n', '<leader>hd', gs.diffthis, {desc="Diff this"})
            map('n', '<leader>hD', function() gs.diffthis('~') end, {desc="Diff this ~"})
            map('n', '<leader>td', gs.toggle_deleted, {desc="Toggle deleted"})

            map({'o', 'x'}, 'ih', ':<C-U>Gitsigns select_hunk<CR>', {desc="Select hunk"})
          end
        })
      end)
    end,
  },

  {
    "tpope/vim-fugitive",
    cmd = { "Git", "Gdiffsplit", "Gread", "Gwrite", "Ggrep", "GMove", "GDelete", "GBrowse" },
    keys = {
      { "<leader>gs", "<cmd>Git<cr>", desc = "Git status" },
      { "<leader>gc", "<cmd>Git commit<cr>", desc = "Git commit" },
      { "<leader>gp", "<cmd>Git push<cr>", desc = "Git push" },
      { "<leader>gl", "<cmd>Git pull<cr>", desc = "Git pull" },
      { "<leader>gb", "<cmd>Git blame<cr>", desc = "Git blame" },
      { "<leader>gd", "<cmd>Gdiffsplit<cr>", desc = "Git diff split" },
    },
  },

  -- ========== DEBUGGING (DAP) ==========
  {
    "mfussenegger/nvim-dap",
    dependencies = {
      "rcarriga/nvim-dap-ui",
      "theHamsta/nvim-dap-virtual-text",
      "nvim-neotest/nvim-nio",
      "mfussenegger/nvim-dap-python",
    },
    keys = {
      { "<F5>", function() require("dap").continue() end, desc = "Debug: Start/Continue" },
      { "<F10>", function() require("dap").step_over() end, desc = "Debug: Step Over" },
      { "<F11>", function() require("dap").step_into() end, desc = "Debug: Step Into" },
      { "<F12>", function() require("dap").step_out() end, desc = "Debug: Step Out" },
      { "<leader>db", function() require("dap").toggle_breakpoint() end, desc = "Debug: Toggle Breakpoint" },
      { "<leader>dB", function() require("dap").set_breakpoint(vim.fn.input('Breakpoint condition: ')) end, desc = "Debug: Set Conditional Breakpoint" },
      { "<leader>dr", function() require("dap").repl.open() end, desc = "Debug: Open REPL" },
      { "<leader>dl", function() require("dap").run_last() end, desc = "Debug: Run Last" },
      { "<leader>dt", function() require("dapui").toggle() end, desc = "Debug: Toggle UI" },
    },
    config = function()
      local dap = safe_require("dap")
      local dapui = safe_require("dapui")
      local dap_virtual_text = safe_require("nvim-dap-virtual-text")

      if not (dap and dapui and dap_virtual_text) then return end

      dapui.setup({
        icons = { expanded = "", collapsed = "", current_frame = "" },
        mappings = {
          expand = { "<CR>", "<2-LeftMouse>" },
          open = "o",
          remove = "d",
          edit = "e",
          repl = "r",
          toggle = "t",
        },
        expand_lines = vim.fn.has("nvim-0.7") == 1,
        layouts = {
          {
            elements = {
              { id = "scopes", size = 0.25 },
              "breakpoints",
              "stacks",
              "watches",
            },
            size = 40,
            position = "left",
          },
          {
            elements = {
              "repl",
              "console",
            },
            size = 0.25,
            position = "bottom",
          },
        },
        controls = {
          enabled = true,
          element = "repl",
          icons = {
            pause = "",
            play = "",
            step_into = "",
            step_over = "",
            step_out = "",
            step_back = "",
            run_last = "",
            terminate = "",
          },
        },
        floating = {
          max_height = nil,
          max_width = nil,
          border = "single",
          mappings = {
            close = { "q", "<Esc>" },
          },
        },
        windows = { indent = 1 },
        render = {
          max_type_length = nil,
          max_value_lines = 100,
        }
      })

      dap_virtual_text.setup({
        enabled = true,
        enabled_commands = true,
        highlight_changed_variables = true,
        highlight_new_as_changed = false,
        show_stop_reason = true,
        commented = false,
        only_first_definition = true,
        all_references = false,
        clear_on_continue = false,
        display_callback = function(variable, buf, stackframe, node, options)
          if options.virt_text_pos == 'inline' then
            return ' = ' .. variable.value
          else
            return variable.name .. ' = ' .. variable.value
          end
        end,
        virt_text_pos = vim.fn.has 'nvim-0.10' == 1 and 'inline' or 'eol',
        all_frames = false,
        virt_lines = false,
        virt_text_win_col = nil
      })

      dap.listeners.after.event_initialized["dapui_config"] = function()
        dapui.open()
      end
      dap.listeners.before.event_terminated["dapui_config"] = function()
        dapui.close()
      end
      dap.listeners.before.event_exited["dapui_config"] = function()
        dapui.close()
      end

      vim.fn.sign_define('DapBreakpoint', { text = '', texthl = 'DapBreakpoint', linehl = '', numhl = '' })
      vim.fn.sign_define('DapBreakpointCondition', { text = '', texthl = 'DapBreakpointCondition', linehl = '', numhl = '' })
      vim.fn.sign_define('DapLogPoint', { text = '.>', texthl = 'DapLogPoint', linehl = '', numhl = '' })
      vim.fn.sign_define('DapStopped', { text = '', texthl = 'DapStopped', linehl = 'DapStoppedLine', numhl = '' })
      vim.fn.sign_define('DapBreakpointRejected', { text = '', texthl = 'DapBreakpointRejected', linehl = '', numhl = '' })

      -- FIXED: Use Mason-installed debugpy path for reliability
      local dap_python = safe_require("dap-python")
      if dap_python then
        local mason_registry_ok, mason_registry = pcall(require, "mason-registry")
        
        if mason_registry_ok and mason_registry.is_installed("debugpy") then
          -- Use Mason-installed debugpy
          local debugpy_path = mason_registry.get_package("debugpy"):get_install_path() .. "/venv/bin/python"
          dap_python.setup(debugpy_path)
          _G.nvim_ide.dap_adapters.python = true
        elseif command_exists("python3") then
          -- Fallback to system python with debugpy check
          local debugpy_cmd = "python3 -c 'import sys; import debugpy; sys.stdout.write(debugpy.__file__)'"
          local debugpy_check = vim.fn.system(debugpy_cmd):gsub("%s+", "")
          
          if vim.v.shell_error == 0 and debugpy_check ~= "" then
            local python_path = vim.fn.system("which python3"):gsub("%s+", "")
            dap_python.setup(python_path)
            _G.nvim_ide.dap_adapters.python = true
          else
            log("debugpy not found. Install with: :MasonInstall debugpy", log_levels.WARN)
          end
        end
      end

      -- FIXED: Check if codelldb is available
      if command_exists("codelldb") then
        dap.adapters.codelldb = {
          type = 'server',
          port = "${port}",
          executable = {
            command = 'codelldb',
            args = {"--port", "${port}"},
          }
        }

        dap.configurations.rust = {
          {
            name = "Launch",
            type = "codelldb",
            request = "launch",
            program = function()
              return vim.fn.input('Path to executable: ', vim.fn.getcwd() .. '/', 'file')
            end,
            cwd = '${workspaceFolder}',
            stopOnEntry = false,
          },
        }
        _G.nvim_ide.dap_adapters.rust = true
      else
        log("codelldb not found. Install for Rust debugging", log_levels.INFO)
      end

      dap.configurations.java = {
        {
          type = 'java',
          request = 'attach',
          name = "Debug (Attach) - Remote",
          hostName = "127.0.0.1",
          port = 5005,
        },
      }
      _G.nvim_ide.dap_adapters.java = true
    end,
  },

  -- ========== TERMINAL INTEGRATION ==========
  {
    "akinsho/toggleterm.nvim",
    version = "*",
    keys = {
      { "<C-\\>", "<cmd>ToggleTerm<cr>", desc = "Toggle terminal" },
      { "<leader>tf", "<cmd>ToggleTerm direction=float<cr>", desc = "Float terminal" },
      { "<leader>th", "<cmd>ToggleTerm direction=horizontal<cr>", desc = "Horizontal terminal" },
      { "<leader>tv", "<cmd>ToggleTerm direction=vertical size=80<cr>", desc = "Vertical terminal" },
    },
    config = function()
      setup_plugin("toggleterm", function(toggleterm)
        toggleterm.setup({
          size = function(term)
            if term.direction == "horizontal" then
              return 15
            elseif term.direction == "vertical" then
              return vim.o.columns * 0.3
            end
          end,
          open_mapping = [[<c-\>]],
          hide_numbers = true,
          shade_terminals = true,
          shading_factor = 2,
          start_in_insert = true,
          insert_mappings = true,
          terminal_mappings = true,
          persist_size = true,
          persist_mode = true,
          direction = "float",
          close_on_exit = true,
          shell = vim.o.shell,
          auto_scroll = true,
          float_opts = {
            border = "curved",
            winblend = 0,
            highlights = {
              border = "Normal",
              background = "Normal",
            },
          },
          winbar = {
            enabled = false,
            name_formatter = function(term)
              return term.name
            end
          },
        })

        function _G.set_terminal_keymaps()
          local opts = {buffer = 0}
          vim.keymap.set('t', '<esc>', [[<C-\><C-n>]], opts)
          vim.keymap.set('t', 'jk', [[<C-\><C-n>]], opts)
          vim.keymap.set('t', '<C-h>', [[<Cmd>wincmd h<CR>]], opts)
          vim.keymap.set('t', '<C-j>', [[<Cmd>wincmd j<CR>]], opts)
          vim.keymap.set('t', '<C-k>', [[<Cmd>wincmd k<CR>]], opts)
          vim.keymap.set('t', '<C-l>', [[<Cmd>wincmd l<CR>]], opts)
          vim.keymap.set('t', '<C-w>', [[<C-\><C-n><C-w>]], opts)
        end

        vim.cmd('autocmd! TermOpen term://* lua set_terminal_keymaps()')
      end)
    end,
  },

  -- ========== PROJECT MANAGEMENT ==========
  {
    "folke/persistence.nvim",
    event = "BufReadPre",
    config = function()
      setup_plugin("persistence", function(persistence)
        persistence.setup({
          dir = vim.fn.expand(vim.fn.stdpath("state") .. "/sessions/"),
          options = { "buffers", "curdir", "tabpages", "winsize", "help", "globals", "skiprtp" },
          pre_save = nil,
        })
      end)
    end,
    keys = {
      { "<leader>qs", function() require("persistence").load() end, desc = "Restore Session" },
      { "<leader>ql", function() require("persistence").load({ last = true }) end, desc = "Restore Last Session" },
      { "<leader>qd", function() require("persistence").stop() end, desc = "Stop Persistence" },
    },
  },

  -- ========== UI ENHANCEMENTS ==========
  {
    "nvim-lualine/lualine.nvim",
    event = "VeryLazy",
    dependencies = { "nvim-tree/nvim-web-devicons" },
    config = function()
      setup_plugin("lualine", function(lualine)
        local colors = solarized_colors

        lualine.setup({
          options = {
            theme = {
              normal = {
                a = { fg = colors.base03, bg = colors.blue, gui = 'bold' },
                b = { fg = colors.base0, bg = colors.base02 },
                c = { fg = colors.base1, bg = colors.base03 },
              },
              insert = { a = { fg = colors.base03, bg = colors.green, gui = 'bold' } },
              visual = { a = { fg = colors.base03, bg = colors.magenta, gui = 'bold' } },
              replace = { a = { fg = colors.base03, bg = colors.red, gui = 'bold' } },
              command = { a = { fg = colors.base03, bg = colors.yellow, gui = 'bold' } },
              inactive = {
                a = { fg = colors.base01, bg = colors.base03, gui = 'bold' },
                b = { fg = colors.base01, bg = colors.base03 },
                c = { fg = colors.base01, bg = colors.base03 },
              },
            },
            globalstatus = true,
            section_separators = { left = '', right = '' },
            component_separators = { left = '', right = '' },
            disabled_filetypes = { 'NvimTree', 'toggleterm' },
          },
          sections = {
            lualine_a = {
              {
                'mode',
                fmt = function(str)
                  return str:sub(1,1)
                end
              }
            },
            lualine_b = {
              'branch',
              {
                'diff',
                symbols = { added = ' ', modified = ' ', removed = ' ' }
              },
              {
                'diagnostics',
                sources = { 'nvim_diagnostic', 'nvim_lsp' },
                symbols = { error = ' ', warn = ' ', info = ' ', hint = ' ' }
              }
            },
            lualine_c = {
              {
                'filename',
                path = 1,
                symbols = {
                  modified = '[+]',
                  readonly = '[RO]',
                  unnamed = '[No Name]',
                }
              }
            },
            lualine_x = {
              {
                function()
                  local clients = vim.lsp.get_clients({ bufnr = 0 })
                  if next(clients) == nil then
                    return 'No LSP'
                  end
                  local names = {}
                  for _, client in pairs(clients) do
                    table.insert(names, client.name)
                  end
                  return '󰌘 ' .. table.concat(names, ', ')
                end,
                color = { fg = colors.green }
              },
              'encoding',
              'fileformat',
              'filetype'
            },
            lualine_y = {
              {
                function()
                  local dap = safe_require("dap", { silent = true })
                  if dap and dap.status() ~= "" then
                    return " " .. dap.status()
                  end
                  return ""
                end,
                color = { fg = colors.red }
              },
              'progress'
            },
            lualine_z = { 'location' }
          },
          inactive_sections = {
            lualine_a = {},
            lualine_b = {},
            lualine_c = { 'filename' },
            lualine_x = { 'location' },
            lualine_y = {},
            lualine_z = {}
          },
          tabline = {},
          extensions = { 'nvim-tree', 'toggleterm', 'quickfix' }
        })
      end)
    end,
  },

  {
    "akinsho/bufferline.nvim",
    version = "*",
    event = "VeryLazy",
    dependencies = "nvim-tree/nvim-web-devicons",
    config = function()
      setup_plugin("bufferline", function(bufferline)
        bufferline.setup({
          options = {
            mode = "buffers",
            themable = true,
            numbers = "ordinal",
            close_command = function(n) smart_buf_delete() end,
            right_mouse_command = function(n) smart_buf_delete() end,
            left_mouse_command = "buffer %d",
            middle_mouse_command = nil,
            indicator = {
              icon = '▎',
              style = 'icon',
            },
            buffer_close_icon = '󰅖',
            modified_icon = '●',
            close_icon = '',
            left_trunc_marker = '',
            right_trunc_marker = '',
            max_name_length = 30,
            max_prefix_length = 30,
            truncate_names = true,
            tab_size = 21,
            diagnostics = "nvim_lsp",
            diagnostics_update_in_insert = false,
            diagnostics_indicator = function(count, level, diagnostics_dict, context)
              local icon = level:match("error") and " " or " "
              return " " .. icon .. count
            end,
            custom_filter = function(buf_number, buf_numbers)
              if vim.bo[buf_number].filetype ~= "oil" then
                return true
              end
            end,
            offsets = {
              {
                filetype = "NvimTree",
                text = " File Explorer",
                text_align = "left",
                separator = true
              }
            },
            color_icons = true,
            show_buffer_icons = true,
            show_buffer_close_icons = true,
            show_close_icon = true,
            show_tab_indicators = true,
            show_duplicate_prefix = true,
            persist_buffer_sort = true,
            move_wraps_at_ends = false,
            separator_style = "thin",
            enforce_regular_tabs = true,
            always_show_bufferline = true,
            hover = {
              enabled = true,
              delay = 200,
              reveal = {'close'}
            },
            sort_by = 'insert_after_current',
          },
          highlights = require("solarized").bufferline or {},
        })
      end)
    end,
  },

  {
    "rcarriga/nvim-notify",
    event = "VeryLazy",
    config = function()
      setup_plugin("notify", function(notify)
        notify.setup({
          background_colour = solarized_colors.base03,
          fps = 30,
          icons = {
            DEBUG = "",
            ERROR = "",
            INFO = "",
            TRACE = "✎",
            WARN = ""
          },
          level = 2,
          minimum_width = 50,
          render = "wrapped-compact",
          stages = "fade_in_slide_out",
          timeout = 3000,
          top_down = true
        })
        vim.notify = notify
      end)
    end,
  },

  {
    "folke/noice.nvim",
    event = "VeryLazy",
    dependencies = {
      "MunifTanjim/nui.nvim",
      "rcarriga/nvim-notify",
    },
    config = function()
      setup_plugin("noice", function(noice)
        noice.setup({
          lsp = {
            override = {
              ["vim.lsp.util.convert_input_to_markdown_lines"] = true,
              ["vim.lsp.util.stylize_markdown"] = true,
              ["cmp.entry.get_documentation"] = true,
            },
            signature = {
              enabled = false,
            },
            hover = {
              enabled = true,
              silent = false,
            },
            documentation = {
              view = "hover",
              opts = {
                lang = "markdown",
                replace = true,
                render = "plain",
                format = { "{message}" },
                win_options = { concealcursor = "n", conceallevel = 3 },
              },
            },
          },
          presets = {
            bottom_search = true,
            command_palette = true,
            long_message_to_split = true,
            inc_rename = false,
            lsp_doc_border = false,
          },
          messages = {
            enabled = true,
            view = "notify",
            view_error = "notify",
            view_warn = "notify",
            view_history = "messages",
            view_search = "virtualtext",
          },
          cmdline = {
            enabled = true,
            view = "cmdline_popup",
            opts = {},
            format = {
              cmdline = { pattern = "^:", icon = "", lang = "vim" },
              search_down = { kind = "search", pattern = "^/", icon = " ", lang = "regex" },
              search_up = { kind = "search", pattern = "^%?", icon = " ", lang = "regex" },
              filter = { pattern = "^:%s*!", icon = "$", lang = "bash" },
              lua = { pattern = { "^:%s*lua%s+", "^:%s*lua%s*=%s*", "^:%s*=%s*" }, icon = "", lang = "lua" },
              help = { pattern = "^:%s*he?l?p?%s+", icon = "" },
              input = {},
            },
          },
          popupmenu = {
            enabled = true,
            backend = "nui",
            kind_icons = {},
          },
          redirect = {
            view = "popup",
            filter = { event = "msg_show" },
          },
          commands = {
            history = {
              view = "split",
              opts = { enter = true, format = "details" },
              filter = {
                any = {
                  { event = "notify" },
                  { error = true },
                  { warning = true },
                  { event = "msg_show", kind = { "" } },
                  { event = "lsp", kind = "message" },
                },
              },
            },
            last = {
              view = "popup",
              opts = { enter = true, format = "details" },
              filter = {
                any = {
                  { event = "notify" },
                  { error = true },
                  { warning = true },
                  { event = "msg_show", kind = { "" } },
                  { event = "lsp", kind = "message" },
                },
              },
              filter_opts = { count = 1 },
            },
            errors = {
              view = "popup",
              opts = { enter = true, format = "details" },
              filter = { error = true },
              filter_opts = { reverse = true },
            },
          },
          notify = {
            enabled = true,
            view = "notify",
          },
          health = {
            checker = false,
          },
        })
      end)
    end,
  },

  -- ========== STARTUP DASHBOARD ==========
  {
    "nvimdev/dashboard-nvim",
    event = "VimEnter",
    config = function()
      setup_plugin("dashboard", function(dashboard)
        dashboard.setup({
          theme = 'hyper',
          config = {
            week_header = { enable = true },
            shortcut = {
              { desc = '󰊳 Update', group = '@property', action = 'Lazy update', key = 'u' },
              {
                icon = ' ',
                icon_hl = '@variable',
                desc = 'Files',
                group = 'Label',
                action = 'Telescope find_files',
                key = 'f',
              },
              {
                desc = ' Apps',
                group = 'DiagnosticHint',
                action = 'Telescope app',
                key = 'a',
              },
              {
                desc = ' dotfiles',
                group = 'Number',
                action = 'Telescope dotfiles',
                key = 'd',
              },
            },
            packages = { enable = true },
            project = {
              enable = true,
              limit = 8,
              icon = '󰏓',
              label = 'Recent Projects',
              action = 'Telescope find_files cwd='
            },
            mru = {
              limit = 10,
              icon = '',
              label = 'Most Recent Files',
            },
            footer = function()
              local stats = require("lazy").stats()
              local ms = (math.floor(stats.startuptime * 100 + 0.5) / 100)
              return {
                "⚡ Neovim loaded " .. stats.loaded .. "/" .. stats.count .. " plugins in " .. ms .. "ms",
                "🟢 Neovim IDE Ready - " .. os.date("%Y-%m-%d %H:%M:%S")
              }
            end,
          },
        })
      end)
    end,
    dependencies = { {'nvim-tree/nvim-web-devicons'}}
  },

  -- ========== CODE FORMATTING ==========
  {
    "nvimtools/none-ls.nvim",
    event = { "BufReadPre", "BufNewFile" },
    dependencies = { "mason.nvim" },
    config = function()
      local null_ls = safe_require("null-ls")
      if not null_ls then return end

      -- FIXED: Create augroup before using it
      local augroup = vim.api.nvim_create_augroup("LspFormatting", {})

      null_ls.setup({
        root_dir = require("null-ls.utils").root_pattern(".null-ls-root", ".neoconf.json", "Makefile", ".git"),
        sources = {
          -- Python
          null_ls.builtins.formatting.black,
          null_ls.builtins.formatting.isort,
          null_ls.builtins.diagnostics.flake8,

          -- Fortran
          -- Install: pip3 install --user fprettify
          null_ls.builtins.formatting.fprettify.with({
            condition = function(utils)
              return utils.root_has_file({"*.f90", "*.f95", "*.f03", "*.f08"})
            end,
          }),

          -- SQL (multiple formatters - uses first available)
          -- Install: npm install -g sql-formatter
          null_ls.builtins.formatting.sql_formatter.with({
            extra_args = { "-l", "postgresql" },
          }),
          -- OR: pip3 install --user sqlfluff
          null_ls.builtins.formatting.sqlfluff.with({
            extra_args = { "--dialect", "postgres" },
          }),
          -- OR: pip3 install --user sqlfmt
          null_ls.builtins.formatting.sqlfmt,
          
          -- VHDL (limited support)
          -- Note: vhdl_beautify requires Emacs vhdl-mode, not practical
          -- Alternative: Use external tools like vsg (VHDL Style Guide)
          -- Install: pip3 install --user vsg
          -- Then create custom null-ls source or format externally

          -- Web technologies
          null_ls.builtins.formatting.prettier.with({
            filetypes = { "html", "css", "javascript", "typescript", "json", "yaml", "markdown" },
          }),

          -- Java
          null_ls.builtins.formatting.google_java_format,

          -- Shell
          null_ls.builtins.formatting.shfmt,

          -- General
          null_ls.builtins.code_actions.gitsigns,
        },
        on_attach = function(client, bufnr)
          if client.supports_method("textDocument/formatting") then
            vim.api.nvim_clear_autocmds({ group = augroup, buffer = bufnr })
            vim.api.nvim_create_autocmd("BufWritePre", {
              group = augroup,
              buffer = bufnr,
              callback = function()
                vim.lsp.buf.format({
                  filter = function(client)
                    return client.name == "null-ls"
                  end,
                  bufnr = bufnr,
                })
              end,
            })
          end
        end,
      })
    end,
  },

  -- ========== ADDITIONAL UTILITIES ==========
  {
    "numToStr/Comment.nvim",
    keys = {
      { "gcc", mode = "n", desc = "Comment toggle current line" },
      { "gc", mode = { "n", "o" }, desc = "Comment toggle linewise" },
      { "gc", mode = "x", desc = "Comment toggle linewise (visual)" },
      { "gbc", mode = "n", desc = "Comment toggle current block" },
      { "gb", mode = { "n", "o" }, desc = "Comment toggle blockwise" },
      { "gb", mode = "x", desc = "Comment toggle blockwise (visual)" },
    },
    config = function()
      setup_plugin("Comment", function(comment)
        comment.setup({
          pre_hook = require('ts_context_commentstring.integrations.comment_nvim').create_pre_hook(),
        })
      end)
    end,
    dependencies = {
      "JoosepAlviste/nvim-ts-context-commentstring",
    },
  },

  {
    "folke/which-key.nvim",
    event = "VeryLazy",
    config = function()
      setup_plugin("which-key", function(wk)
        wk.setup({
          preset = "modern",
          delay = 200,
          expand = 1,
          notify = true,
          triggers = {
            { "<auto>", mode = "nixsotc" },
            { "s", mode = { "n", "v" } },
          },
        })

        wk.add({
          { "<leader>b", group = "Buffer" },
          { "<leader>c", group = "Code" },
          { "<leader>d", group = "Debug" },
          { "<leader>f", group = "Find" },
          { "<leader>g", group = "Git" },
          { "<leader>h", group = "Hunk" },
          { "<leader>l", group = "LSP" },
          { "<leader>q", group = "Session" },
          { "<leader>r", group = "Run/Replace" },
          { "<leader>s", group = "Solarized/Split" },
          { "<leader>t", group = "Terminal/Toggle/Theme" },
          { "<leader>w", group = "Workspace" },
          { "<leader>x", group = "Trouble/Diagnostics" },
        })
      end)
    end,
  },

  {
    "folke/trouble.nvim",
    cmd = "Trouble",
    keys = {
      { "<leader>xx", "<cmd>Trouble diagnostics toggle<cr>", desc = "Diagnostics (Trouble)" },
      { "<leader>xX", "<cmd>Trouble diagnostics toggle filter.buf=0<cr>", desc = "Buffer Diagnostics (Trouble)" },
      { "<leader>cs", "<cmd>Trouble symbols toggle focus=false<cr>", desc = "Symbols (Trouble)" },
      { "<leader>cl", "<cmd>Trouble lsp toggle focus=false win.position=right<cr>", desc = "LSP Definitions / references / ... (Trouble)" },
      { "<leader>xL", "<cmd>Trouble loclist toggle<cr>", desc = "Location List (Trouble)" },
      { "<leader>xQ", "<cmd>Trouble qflist toggle<cr>", desc = "Quickfix List (Trouble)" },
    },
    config = function()
      setup_plugin("trouble", function(trouble)
        trouble.setup({
          modes = {
            preview_float = {
              mode = "diagnostics",
              preview = {
                type = "float",
                relative = "editor",
                border = "rounded",
                title = "Preview",
                title_pos = "center",
                position = { 0, -2 },
                size = { width = 0.3, height = 0.3 },
                zindex = 200,
              },
            },
          },
        })
      end)
    end,
  },

  {
    "windwp/nvim-autopairs",
    event = "InsertEnter",
    config = function()
      setup_plugin("nvim-autopairs", function(autopairs)
        autopairs.setup({
          check_ts = true,
          ts_config = {
            lua = {'string'},
            javascript = {'template_string'},
            java = false,
          },
          disable_filetype = { "TelescopePrompt" , "vim" },
          fast_wrap = {
            map = '<M-e>',
            chars = { '{', '[', '(', '"', "'" },
            pattern = [=[[%'%"%)%>%]%)%}%,]]=],
            end_key = '',
            keys = 'qwertyuiopzxcvbnmasdfghjkl',
            check_comma = true,
            highlight = 'Search',
            highlight_grey='Comment'
          },
        })

        local cmp_autopairs = safe_require("nvim-autopairs.completion.cmp", { silent = true })
        local cmp = safe_require("cmp", { silent = true })
        if cmp_autopairs and cmp then
          cmp.event:on('confirm_done', cmp_autopairs.on_confirm_done())
        end
      end)
    end
  },

  {
    "kylechui/nvim-surround",
    version = "*",
    event = "VeryLazy",
    config = function()
      setup_plugin("nvim-surround", function(surround)
        surround.setup({})
      end)
    end
  },

}, {
  defaults = { lazy = true },
  install = { colorscheme = { "solarized" } },
  checker = {
    enabled = true,
    notify = false,
    frequency = 3600,
  },
  change_detection = {
    enabled = true,
    notify = false,
  },
  performance = {
    cache = {
      enabled = true,
    },
    reset_packpath = true,
    rtp = {
      disabled_plugins = {
        "gzip", "matchit", "matchparen", "netrwPlugin",
        "tarPlugin", "tohtml", "tutor", "zipPlugin"
      },
    },
  },
  ui = {
    size = { width = 0.8, height = 0.8 },
    wrap = true,
    border = "rounded",
    backdrop = 60,
    title = "Neovim IDE Plugin Manager",
    title_pos = "center",
    icons = {
      cmd = " ",
      config = "",
      event = " ",
      ft = " ",
      init = " ",
      import = " ",
      keys = " ",
      lazy = "󰒲 ",
      loaded = "●",
      not_loaded = "○",
      plugin = " ",
      runtime = " ",
      require = "󰢱 ",
      source = " ",
      start = " ",
      task = "✔ ",
      list = {
        "●",
        "➜",
        "★",
        "‒",
      },
    },
  },
  diff = {
    cmd = "git",
  },
})

-- =====================================================
-- 9. COMPREHENSIVE KEYMAPS
-- =====================================================

local function map(mode, lhs, rhs, opts)
  opts = vim.tbl_extend("force", { silent = true, noremap = true }, opts or {})
  vim.keymap.set(mode, lhs, rhs, opts)
end

map("n", "<Space>", "<Nop>")

-- ========== GENERAL NAVIGATION ==========
map("i", "jk", "<Esc>", { desc = "Exit insert mode" })
map("i", "kj", "<Esc>", { desc = "Exit insert mode" })
map("t", "<Esc>", [[<C-\><C-n>]], { desc = "Exit terminal mode" })
map("t", "jk", [[<C-\><C-n>]], { desc = "Exit terminal mode" })

map("n", "<C-h>", "<C-w>h", { desc = "Go to left window" })
map("n", "<C-j>", "<C-w>j", { desc = "Go to lower window" })
map("n", "<C-k>", "<C-w>k", { desc = "Go to upper window" })
map("n", "<C-l>", "<C-w>l", { desc = "Go to right window" })

map("n", "<C-Up>", "<cmd>resize +2<cr>", { desc = "Increase window height" })
map("n", "<C-Down>", "<cmd>resize -2<cr>", { desc = "Decrease window height" })
map("n", "<C-Left>", "<cmd>vertical resize -2<cr>", { desc = "Decrease window width" })
map("n", "<C-Right>", "<cmd>vertical resize +2<cr>", { desc = "Increase window width" })

map("n", "<S-h>", "<cmd>bprevious<cr>", { desc = "Previous buffer" })
map("n", "<S-l>", "<cmd>bnext<cr>", { desc = "Next buffer" })
map("n", "[b", "<cmd>bprevious<cr>", { desc = "Previous buffer" })
map("n", "]b", "<cmd>bnext<cr>", { desc = "Next buffer" })

-- ========== FILE OPERATIONS ==========
map("n", "<leader>w", "<cmd>write<cr>", { desc = "Save file" })
map("n", "<leader>W", "<cmd>wall<cr>", { desc = "Save all files" })
map("n", "<leader>q", "<cmd>quit<cr>", { desc = "Quit" })
map("n", "<leader>Q", "<cmd>qall!<cr>", { desc = "Force quit all" })
map("n", "<leader>bd", smart_buf_delete, { desc = "Delete buffer" })
map("n", "<leader>bD", "<cmd>%bd|e#|bd#<cr>", { desc = "Delete other buffers" })

-- ========== SPLIT MANAGEMENT ==========
map("n", "<leader>sv", "<cmd>vsplit<cr>", { desc = "Split vertically" })
map("n", "<leader>sh", "<cmd>split<cr>", { desc = "Split horizontally" })
map("n", "<leader>se", "<C-w>=", { desc = "Make splits equal" })
map("n", "<leader>sx", "<cmd>close<cr>", { desc = "Close current split" })
map("n", "<leader>so", "<cmd>only<cr>", { desc = "Close other splits" })

-- ========== SEARCH AND REPLACE ==========
map("n", "<leader>nh", "<cmd>nohlsearch<cr>", { desc = "Clear search highlights" })
map("n", "n", "nzzzv", { desc = "Next search result" })
map("n", "N", "Nzzzv", { desc = "Previous search result" })

map("n", "*", "*zzzv", { desc = "Search word under cursor forward" })
map("n", "#", "#zzzv", { desc = "Search word under cursor backward" })

map("n", "<leader>rw", [[:%s/\<<C-r><C-w>\>/<C-r><C-w>/gI<Left><Left><Left>]], { desc = "Replace word under cursor" })
map("v", "<leader>rw", [["hy:%s/\V<C-r>h/<C-r>h/gc<left><left><left>]], { desc = "Replace selected text" })

-- ========== TEXT MANIPULATION ==========
map("v", "<", "<gv", { desc = "Indent left" })
map("v", ">", ">gv", { desc = "Indent right" })

map("n", "<A-j>", "<cmd>move .+1<cr>==", { desc = "Move line down" })
map("n", "<A-k>", "<cmd>move .-2<cr>==", { desc = "Move line up" })
map("i", "<A-j>", "<Esc><cmd>move .+1<cr>==gi", { desc = "Move line down" })
map("i", "<A-k>", "<Esc><cmd>move .-2<cr>==gi", { desc = "Move line up" })
map("v", "<A-j>", ":move '>+1<cr>gv=gv", { desc = "Move selection down" })
map("v", "<A-k>", ":move '<-2<cr>gv=gv", { desc = "Move selection up" })

map("v", "p", '"_dP', { desc = "Paste without yanking" })
map("x", "<leader>p", [["_dP]], { desc = "Paste without yanking" })

map({ "n", "v" }, "<leader>d", [["_d]], { desc = "Delete without yanking" })

-- ========== CLIPBOARD ==========
map({ "n", "v" }, "<leader>y", [["+y]], { desc = "Copy to system clipboard" })
map("n", "<leader>Y", [["+Y]], { desc = "Copy line to system clipboard" })

-- ========== CENTER SCREEN ON NAVIGATION ==========
map("n", "<C-d>", "<C-d>zz", { desc = "Half page down and center" })
map("n", "<C-u>", "<C-u>zz", { desc = "Half page up and center" })
map("n", "G", "Gzz", { desc = "Go to end and center" })
map("n", "gg", "ggzz", { desc = "Go to start and center" })

-- ========== DIAGNOSTICS ==========
map("n", "[d", vim.diagnostic.goto_prev, { desc = "Previous diagnostic" })
map("n", "]d", vim.diagnostic.goto_next, { desc = "Next diagnostic" })
map("n", "[e", function() vim.diagnostic.goto_prev({ severity = vim.diagnostic.severity.ERROR }) end, { desc = "Previous error" })
map("n", "]e", function() vim.diagnostic.goto_next({ severity = vim.diagnostic.severity.ERROR }) end, { desc = "Next error" })
map("n", "[w", function() vim.diagnostic.goto_prev({ severity = vim.diagnostic.severity.WARN }) end, { desc = "Previous warning" })
map("n", "]w", function() vim.diagnostic.goto_next({ severity = vim.diagnostic.severity.WARN }) end, { desc = "Next warning" })
map("n", "<leader>xl", vim.diagnostic.setloclist, { desc = "Open diagnostic location list" })
map("n", "<leader>xq", vim.diagnostic.setqflist, { desc = "Open diagnostic quickfix list" })

-- ========== QUICK ACTIONS ==========
map("n", "<leader>cc", function()
  vim.cmd("edit " .. vim.fn.stdpath("config") .. "/init.lua")
end, { desc = "Edit config" })

map("n", "<leader><leader>", function()
  vim.cmd("source %")
end, { desc = "Source current file" })

map("n", "<leader>rn", function()
  vim.opt.relativenumber = not vim.opt.relativenumber:get()
end, { desc = "Toggle relative numbers" })

-- ========== CODE EXECUTION SYSTEM ==========

local code_runners = {
  python = function(file)
    local interpreters = { "python3", "python", "py" }
    for _, interpreter in ipairs(interpreters) do
      if command_exists(interpreter) then
        return interpreter .. " " .. vim.fn.shellescape(file)
      end
    end
    return nil
  end,

  rust = function(file)
    local dir = vim.fn.fnamemodify(file, ":h")
    
    -- Check for Cargo project
    if vim.fn.filereadable(safe_path_join(dir, "Cargo.toml")) == 1 then
      return "cd " .. vim.fn.shellescape(dir) .. " && cargo run"
    else
      -- Single file compilation
      if not command_exists("rustc") then
        return nil
      end
      
      local exe = vim.fn.fnamemodify(file, ":r")
      local content = vim.fn.readfile(file)
      
      -- FIXED: Detect external crates beyond std
      local has_external_crate = false
      local has_std = false
      
      for _, line in ipairs(content) do
        -- Check for external crate declarations
        if line:match("^extern%s+crate%s+(%w+)") then
          local crate_name = line:match("^extern%s+crate%s+(%w+)")
          if crate_name ~= "std" then
            has_external_crate = true
            break
          end
        end
        -- Check for non-std use statements (common external crates)
        if line:match("^use%s+(%w+)::") then
          local crate_name = line:match("^use%s+(%w+)::")
          if crate_name ~= "std" and crate_name ~= "core" then
            has_external_crate = true
            break
          end
        end
        -- Check for std usage
        if line:match("use%s+std::") then
          has_std = true
        end
      end
      
      if has_external_crate then
        vim.notify(
          "Warning: External crates detected. Single-file compilation may fail.\n" ..
          "Create a Cargo.toml for projects with dependencies.",
          vim.log.levels.WARN
        )
      end
      
      local compile_cmd = "rustc " .. vim.fn.shellescape(file)
      
      -- Add edition flag for std usage
      if has_std then
        compile_cmd = compile_cmd .. " --edition 2021"
      end
      
      return compile_cmd .. " -o " .. vim.fn.shellescape(exe) .. " && " .. vim.fn.shellescape(exe)
    end
  end,

  java = function(file)
    if not command_exists("javac") then
      return nil
    end
    
    local dir = vim.fn.fnamemodify(file, ":h")
    local name = vim.fn.fnamemodify(file, ":t:r")
    
    -- Check for Maven/Gradle project
    local project_root = dir
    local parent = vim.fn.fnamemodify(dir, ":h")
    
    -- Look for pom.xml or build.gradle up to 3 levels
    for i = 1, 3 do
      if vim.fn.filereadable(safe_path_join(parent, "pom.xml")) == 1 then
        return "cd " .. vim.fn.shellescape(parent) .. " && mvn compile exec:java"
      elseif vim.fn.filereadable(safe_path_join(parent, "build.gradle")) == 1 then
        return "cd " .. vim.fn.shellescape(parent) .. " && gradle run"
      end
      parent = vim.fn.fnamemodify(parent, ":h")
    end
    
    -- Single file compilation with classpath consideration
    local classpath = dir
    -- Check for common library directories
    local lib_dirs = { "lib", "libs", "../lib" }
    for _, lib in ipairs(lib_dirs) do
      local lib_path = safe_path_join(dir, lib)
      if vim.fn.isdirectory(lib_path) == 1 then
        classpath = classpath .. ":" .. lib_path .. "/*"
      end
    end
    
    local compile_cmd = "cd " .. vim.fn.shellescape(dir) .. " && javac"
    if classpath ~= dir then
      compile_cmd = compile_cmd .. " -cp " .. vim.fn.shellescape(classpath)
    end
    
    compile_cmd = compile_cmd .. " " .. vim.fn.shellescape(file) .. " && java"
    if classpath ~= dir then
      compile_cmd = compile_cmd .. " -cp " .. vim.fn.shellescape(classpath)
    end
    
    return compile_cmd .. " " .. name
  end,

  javascript = function(file)
    if command_exists("node") then
      return "node " .. vim.fn.shellescape(file)
    end
    return nil
  end,

  typescript = function(file)
    if command_exists("tsx") then
      return "tsx " .. vim.fn.shellescape(file)
    elseif command_exists("ts-node") then
      return "ts-node " .. vim.fn.shellescape(file)
    end
    return nil
  end,

  sql = function(file)
    if command_exists("psql") then
      return "psql -f " .. vim.fn.shellescape(file)
    end
    return nil
  end,

  fortran = function(file)
    if not command_exists("gfortran") then
      return nil
    end
    local exe = vim.fn.fnamemodify(file, ":r")
    return "gfortran -o " .. vim.fn.shellescape(exe) .. " " .. vim.fn.shellescape(file) .. " && " .. vim.fn.shellescape(exe)
  end,

  lua = function(file)
    return "lua " .. vim.fn.shellescape(file)
  end,
}

local function run_code()
  local file = vim.fn.expand("%:p")
  local filetype = vim.bo.filetype

  if file == "" or vim.fn.filereadable(file) ~= 1 then
    vim.notify("No valid file to run", vim.log.levels.ERROR)
    return
  end

  if vim.bo.modified then
    vim.cmd("write")
  end

  local runner = code_runners[filetype]
  if not runner then
    vim.notify("No runner configured for " .. filetype, vim.log.levels.WARN)
    return
  end

  local cmd = runner(file)
  if not cmd then
    vim.notify("No suitable runtime found for " .. filetype, vim.log.levels.ERROR)
    return
  end

  local toggleterm = safe_require("toggleterm.terminal", { silent = true })
  if toggleterm then
    local Terminal = toggleterm.Terminal
    local terminal = Terminal:new({
      cmd = cmd,
      direction = "float",
      close_on_exit = false,
      float_opts = {
        border = "curved",
        winblend = 0,
      }
    })
    terminal:toggle()
  else
    vim.cmd("split | terminal " .. cmd)
  end
end

map("n", "<F5>", run_code, { desc = "Run current file" })
map("n", "<leader>rr", run_code, { desc = "Run current file" })

-- ========== PROJECT MANAGEMENT ==========
map("n", "<leader>cd", function()
  local root = find_project_root()
  vim.cmd("cd " .. root)
  vim.notify("Changed to: " .. root)
end, { desc = "Change to project root" })

-- =====================================================
-- 10. AUTOCMDS AND EVENT HANDLING
-- =====================================================

local function setup_autocmds()
  local augroup = vim.api.nvim_create_augroup
  local autocmd = vim.api.nvim_create_autocmd

  autocmd("TextYankPost", {
    group = augroup("HighlightYank", { clear = true }),
    callback = function()
      vim.highlight.on_yank({ timeout = 200 })
    end,
  })

  autocmd("BufReadPost", {
    group = augroup("RestoreCursor", { clear = true }),
    callback = function(args)
      local mark = vim.api.nvim_buf_get_mark(args.buf, '"')
      local lcount = vim.api.nvim_buf_line_count(args.buf)
      if mark[1] > 0 and mark[1] <= lcount then
        pcall(vim.api.nvim_win_set_cursor, 0, mark)
      end
    end,
  })

  autocmd("VimResized", {
    group = augroup("ResizeWindows", { clear = true }),
    callback = function()
      local current_tab = vim.fn.tabpagenr()
      vim.cmd("tabdo wincmd =")
      vim.cmd("tabnext " .. current_tab)
    end,
  })

  autocmd("FileType", {
    group = augroup("CloseWithQ", { clear = true }),
    pattern = {
      "help", "man", "qf", "lspinfo", "checkhealth", "startuptime",
      "notify", "null-ls-info", "dap-repl"
    },
    callback = function(event)
      vim.bo[event.buf].buflisted = false
      vim.keymap.set("n", "q", "<cmd>close<cr>", {
        buffer = event.buf,
        silent = true,
        desc = "Close window"
      })
    end,
  })

  autocmd("BufWritePre", {
    group = augroup("TrimWhitespace", { clear = true }),
    callback = function()
      local exclude_ft = { "markdown", "diff", "gitcommit" }
      if vim.tbl_contains(exclude_ft, vim.bo.filetype) then
        return
      end

      local save_cursor = vim.fn.getpos(".")
      pcall(function()
        vim.cmd([[%s/\s\+$//e]])
      end)
      vim.fn.setpos(".", save_cursor)
    end,
  })

  autocmd("FileType", {
    group = augroup("LanguageSettings", { clear = true }),
    pattern = { "html", "css", "javascript", "typescript", "json", "yaml" },
    callback = function()
      vim.opt_local.shiftwidth = 2
      vim.opt_local.tabstop = 2
      vim.opt_local.softtabstop = 2
    end,
  })

  autocmd("FileType", {
    group = augroup("PythonSettings", { clear = true }),
    pattern = "python",
    callback = function()
      vim.opt_local.colorcolumn = "88,120"
      vim.opt_local.textwidth = 88
    end,
  })

  autocmd("FileType", {
    group = augroup("FortranSettings", { clear = true }),
    pattern = "fortran",
    callback = function()
      vim.opt_local.colorcolumn = "72,132"
      vim.opt_local.textwidth = 72
    end,
  })

  autocmd("FileType", {
    group = augroup("VhdlSettings", { clear = true }),
    pattern = "vhdl",
    callback = function()
      vim.opt_local.colorcolumn = "80"
      vim.opt_local.textwidth = 80
    end,
  })

  autocmd("FileType", {
    group = augroup("JavaSettings", { clear = true }),
    pattern = "java",
    callback = function()
      vim.opt_local.colorcolumn = "100,120"
      vim.opt_local.textwidth = 100
    end,
  })

  autocmd("FileType", {
    group = augroup("MarkdownSettings", { clear = true }),
    pattern = "markdown",
    callback = function()
      vim.opt_local.wrap = true
      vim.opt_local.spell = true
      vim.opt_local.linebreak = true
      vim.opt_local.conceallevel = 2
    end,
  })

  autocmd("FileType", {
    group = augroup("SqlSettings", { clear = true }),
    pattern = "sql",
    callback = function()
      vim.opt_local.commentstring = "-- %s"
    end,
  })

  autocmd("BufReadPre", {
    group = augroup("LargeFile", { clear = true }),
    callback = function(args)
      local ok, stats = pcall(vim.uv.fs_stat, vim.api.nvim_buf_get_name(args.buf))
      if ok and stats and stats.size > 1024 * 1024 then
        vim.b[args.buf].large_file = true
        vim.opt_local.eventignore:append({
          "FileType", "Syntax", "BufNewFile", "BufRead", "BufReadPost"
        })
        vim.opt_local.foldmethod = "manual"
        vim.opt_local.undolevels = -1
        vim.opt_local.undoreload = 0
        vim.opt_local.list = false
      end
    end,
  })

  autocmd("TermOpen", {
    group = augroup("TerminalSettings", { clear = true }),
    callback = function()
      vim.opt_local.number = false
      vim.opt_local.relativenumber = false
      vim.opt_local.scrolloff = 0
      vim.cmd("startinsert")
    end,
  })

  autocmd({ "FocusGained", "BufEnter", "CursorHold", "CursorHoldI" }, {
    group = augroup("AutoReload", { clear = true }),
    callback = function()
      if vim.fn.mode() ~= 'c' then
        vim.cmd("checktime")
      end
    end,
  })

  autocmd("ColorScheme", {
    group = augroup("SolarizedEnforcement", { clear = true }),
    pattern = "solarized",
    callback = function()
      vim.defer_fn(apply_solarized_highlights, 50)
    end,
  })
end

setup_autocmds()

-- =====================================================
-- 11. THEME MANAGEMENT SYSTEM
-- =====================================================

local function get_theme_for_time()
  local hour = tonumber(os.date("%H"))
  return (hour >= 6 and hour < 18) and "light" or "dark"
end

local auto_switching_enabled = true
local theme_timer = nil

local function auto_switch_theme()
  if not auto_switching_enabled then return end

  local auto_bg = get_theme_for_time()
  local current_bg = vim.o.background

  if auto_bg ~= current_bg then
    vim.o.background = auto_bg
    pcall(vim.cmd.colorscheme, "solarized")
    vim.schedule(function()
      apply_solarized_highlights()
      vim.cmd("doautocmd ColorScheme")
    end)
    vim.notify("Auto-switched to Solarized " .. auto_bg .. " mode", vim.log.levels.INFO)
  end
end

local function setup_auto_theme_switching()
  -- FIXED: Proper cleanup of existing timer
  if theme_timer then
    pcall(function()
      theme_timer:stop()
      theme_timer:close()
    end)
    theme_timer = nil
  end

  vim.o.background = get_theme_for_time()

  theme_timer = vim.uv.new_timer()
  if theme_timer then
    theme_timer:start(0, 1800000, function()
      vim.schedule(auto_switch_theme)
    end)
  end
end

map("n", "<leader>tt", function()
  local current_bg = vim.o.background
  local new_bg = current_bg == "dark" and "light" or "dark"
  vim.o.background = new_bg
  pcall(vim.cmd.colorscheme, "solarized")
  vim.schedule(function()
    apply_solarized_highlights()
    vim.cmd("doautocmd ColorScheme")
  end)
  vim.notify("Switched to Solarized " .. new_bg .. " mode", vim.log.levels.INFO)
  auto_switching_enabled = false
  vim.defer_fn(function() auto_switching_enabled = true end, 7200000)
end, { desc = "Toggle Solarized theme" })

map("n", "<leader>td", function()
  vim.o.background = "dark"
  pcall(vim.cmd.colorscheme, "solarized")
  vim.defer_fn(apply_solarized_highlights, 50)
  vim.notify("Solarized Dark activated", vim.log.levels.INFO)
end, { desc = "Solarized Dark" })

map("n", "<leader>tl", function()
  vim.o.background = "light"
  pcall(vim.cmd.colorscheme, "solarized")
  vim.defer_fn(apply_solarized_highlights, 50)
  vim.notify("Solarized Light activated", vim.log.levels.INFO)
end, { desc = "Solarized Light" })

-- =====================================================
-- 12. CUSTOM COMMANDS
-- =====================================================

vim.api.nvim_create_user_command("Health", function(opts)
  local health = {}

  health["Neovim"] = vim.version() and tostring(vim.version()) or "Unknown"
  health["OS"] = vim.uv.os_uname().sysname .. " " .. (vim.uv.os_uname().release or "")
  health["Clipboard"] = vim.fn.has("clipboard") == 1 and "Available" or "Not available"
  health["Git"] = command_exists("git") and "Available" or "Not available"

  local lsp_clients = vim.lsp.get_clients()
  health["LSP Clients"] = #lsp_clients > 0 and (#lsp_clients .. " active") or "None active"

  local lazy = safe_require("lazy", { silent = true })
  if lazy then
    local stats = lazy.stats()
    health["Plugins"] = string.format("%d/%d loaded", stats.loaded, stats.count)
    health["Startup Time"] = string.format("%.2fms", stats.startuptime)
  end

  local memory_mb = collectgarbage("count") / 1024
  health["Memory Usage"] = string.format("%.1fMB", memory_mb)

  health["Theme"] = string.format("Solarized (%s)", vim.o.background)
  health["Auto Theme"] = auto_switching_enabled and "Enabled" or "Disabled"

  if opts.bang then
    print(vim.json.encode(health))
    return
  end

  print("=== Neovim IDE Health Check ===")
  for key, value in pairs(health) do
    print(string.format("%-15s: %s", key, value))
  end

  if next(_G.nvim_ide.failed_modules) then
    print("\nFailed Modules:")
    for module, _ in pairs(_G.nvim_ide.failed_modules) do
      print("  - " .. module)
    end
  end

  if next(_G.nvim_ide.language_servers) then
    print("\nConfigured Language Servers:")
    for server, _ in pairs(_G.nvim_ide.language_servers) do
      print("  - " .. server)
    end
  end

  if next(_G.nvim_ide.dap_adapters) then
    print("\nConfigured DAP Adapters:")
    for adapter, _ in pairs(_G.nvim_ide.dap_adapters) do
      print("  - " .. adapter)
    end
  end
end, { desc = "Show IDE health status", bang = true })

vim.api.nvim_create_user_command("Format", function(opts)
  local range = nil
  if opts.range > 0 then
    range = { start = { opts.line1, 0 }, ["end"] = { opts.line2, 0 } }
  end

  vim.lsp.buf.format({
    async = true,
    range = range,
  })
end, { range = true, desc = "Format buffer or range" })

vim.api.nvim_create_user_command("ProjectRoot", function()
  local root = find_project_root()
  vim.cmd("cd " .. root)
  vim.notify("Changed to: " .. root)
end, { desc = "Navigate to project root" })

vim.api.nvim_create_user_command("CleanUp", function()
  collectgarbage("collect")
  module_cache = {}
  root_cache = {}
  _G.nvim_ide.failed_modules = {}
  collectgarbage("collect")
  vim.notify("IDE cleanup completed - Memory: " .. string.format("%.1fMB", collectgarbage("count") / 1024))
end, { desc = "Clean up memory and reset caches" })

vim.api.nvim_create_user_command("DebugIDE", function()
  local debug_info = {
    startup_time = string.format("%.2fms", (vim.uv.hrtime() - _G.nvim_ide.startup_time) / 1e6),
    memory = string.format("%.2fMB", collectgarbage("count") / 1024),
    failed_modules = vim.tbl_count(_G.nvim_ide.failed_modules),
    lsp_clients = #vim.lsp.get_clients(),
    buffers = #vim.api.nvim_list_bufs(),
    windows = #vim.api.nvim_list_wins(),
    security_mode = _G.nvim_ide.security_mode,
  }
  
  print("=== IDE Debug Information ===")
  for key, value in pairs(debug_info) do
    print(string.format("%-15s: %s", key, value))
  end
  
  -- Plugin load times
  local lazy = safe_require("lazy", { silent = true })
  if lazy then
    print("\n=== Slowest Plugins (>10ms) ===")
    local profile = lazy.profile()
    table.sort(profile, function(a, b) return a.time > b.time end)
    for i = 1, math.min(10, #profile) do
      if profile[i].time > 10 then
        print(string.format("%-30s: %.2fms", profile[i].name, profile[i].time))
      end
    end
  end
end, { desc = "Show IDE debug information" })

-- Memory leak detection
vim.api.nvim_create_autocmd("User", {
  pattern = "LazyCheck",
  callback = function()
    vim.defer_fn(function()
      check_memory()
      if vim.tbl_count(_G.nvim_ide.failed_modules) > 5 then
        log("Multiple module failures detected. Run :DebugIDE for details", log_levels.WARN)
      end
    end, 5000)
  end,
})

vim.api.nvim_create_user_command("SolarizedLight", function()
  vim.o.background = "light"
  pcall(vim.cmd.colorscheme, "solarized")
  vim.defer_fn(apply_solarized_highlights, 50)
  auto_switching_enabled = false
  vim.notify("Solarized Light activated (auto-switching paused)", vim.log.levels.INFO)
end, { desc = "Set Solarized Light theme" })

vim.api.nvim_create_user_command("SolarizedDark", function()
  vim.o.background = "dark"
  pcall(vim.cmd.colorscheme, "solarized")
  vim.defer_fn(apply_solarized_highlights, 50)
  auto_switching_enabled = false
  vim.notify("Solarized Dark activated (auto-switching paused)", vim.log.levels.INFO)
end, { desc = "Set Solarized Dark theme" })

vim.api.nvim_create_user_command("EnableAutoTheme", function()
  auto_switching_enabled = true
  auto_switch_theme()
  vim.notify("Auto theme switching enabled", vim.log.levels.INFO)
end, { desc = "Enable automatic theme switching" })

-- =====================================================
-- 13. KDE/OPENSUSE SPECIFIC OPTIMIZATIONS
-- =====================================================

local function setup_clipboard()
  if vim.fn.has("clipboard") == 0 then
    log("Clipboard feature not available in this build.", log_levels.WARN)
    return
  end

  local clipboard_ok = false

  -- FIXED: Check Wayland first for modern KDE Plasma
  if vim.env.WAYLAND_DISPLAY and command_exists("wl-copy") then
    vim.g.clipboard = {
      name = "wayland",
      copy = {
        ["+"] = "wl-copy --type text/plain",
        ["*"] = "wl-copy --primary --type text/plain",
      },
      paste = {
        ["+"] = "wl-paste --no-newline",
        ["*"] = "wl-paste --primary --no-newline",
      },
    }
    clipboard_ok = true

  elseif vim.env.DISPLAY and command_exists("xclip") then
    vim.g.clipboard = {
      name = "xclip",
      copy = {
        ["+"] = "xclip -quiet -i -selection clipboard",
        ["*"] = "xclip -quiet -i -selection primary",
      },
      paste = {
        ["+"] = "xclip -o -selection clipboard",
        ["*"] = "xclip -o -selection primary",
      },
    }
    clipboard_ok = true

  elseif vim.env.DISPLAY and command_exists("xsel") then
    vim.g.clipboard = {
      name = "xsel",
      copy = {
        ["+"] = "xsel --clipboard --input",
        ["*"] = "xsel --primary --input",
      },
      paste = {
        ["+"] = "xsel --clipboard --output",
        ["*"] = "xsel --primary --output",
      },
    }
    clipboard_ok = true

  elseif vim.fn.has("wsl") == 1 and command_exists("clip.exe") then
    vim.g.clipboard = {
      name = "WSL",
      copy = { ["+"] = "clip.exe", ["*"] = "clip.exe" },
      paste = {
        ["+"] = 'powershell.exe -c [Console]::Out.Write($(Get-Clipboard -Raw).tostring().replace("`r", ""))',
        ["*"] = 'powershell.exe -c [Console]::Out.Write($(Get-Clipboard -Raw).tostring().replace("`r", ""))',
      },
    }
    clipboard_ok = true

  elseif vim.fn.has("macunix") == 1 and command_exists("pbcopy") then
    vim.g.clipboard = {
      name = "macOS",
      copy = { ["+"] = "pbcopy", ["*"] = "pbcopy" },
      paste = { ["+"] = "pbpaste", ["*"] = "pbpaste" },
    }
    clipboard_ok = true
  end

  if not clipboard_ok then
    vim.opt.clipboard = ""
    log("No clipboard provider found. Install wl-clipboard or xclip", log_levels.WARN)
  end
end

setup_clipboard()
setup_auto_theme_switching()

-- =====================================================
-- 14. STARTUP COMPLETION AND INITIALIZATION
-- =====================================================

vim.defer_fn(function()
  if vim.g.colors_name == "solarized" then
    apply_solarized_highlights()
  end
end, 100)

vim.defer_fn(function()
  _G.nvim_ide.initialized = true

  local startup_time = (vim.uv.hrtime() - _G.nvim_ide.startup_time) / 1e6
  local memory_mb = collectgarbage("count") / 1024

  local plugin_info = ""
  local lazy = safe_require("lazy", { silent = true })
  if lazy then
    local stats = lazy.stats()
    plugin_info = string.format(" | %d/%d plugins", stats.loaded, stats.count)
  end

  local status = "READY"
  if startup_time > 1000 then
    status = "SLOW STARTUP"
  elseif next(_G.nvim_ide.failed_modules) then
    status = "MODULE ISSUES"
  end

  local lines = {
    "╔═══════════════════════════════════════════════════════════════════╗",
    "NEOVIM IDE v6.1 - " .. status,
    string.format("Languages: Python, Rust, Fortran, SQL, VHDL, HTML, CSS, JS, Java"),
    string.format("%.1fms startup | %.1fMB memory%s", startup_time, memory_mb, plugin_info),
    "Security: " .. (_G.nvim_ide.security_mode and "ENABLED" or "DISABLED"),
    "Theme: Solarized (" .. vim.o.background .. " mode) | Auto-switching: " .. (auto_switching_enabled and "ON" or "OFF"),
    "LSP Servers: " .. vim.tbl_count(_G.nvim_ide.language_servers) .. " configured",
    "DAP Adapters: " .. vim.tbl_count(_G.nvim_ide.dap_adapters) .. " configured",
    "Platform: " .. _G.nvim_ide.os_type,
  }

  local hour = tonumber(os.date("%H"))
  local greeting = hour < 12 and "Good morning!" or
                  hour < 18 and "Good afternoon!" or
                  "Good evening!"
  table.insert(lines, greeting .. " Your IDE is ready.")
  table.insert(lines, "╚═══════════════════════════════════════════════════════════════════╝")

  vim.notify(table.concat(lines, "\n"), vim.log.levels.INFO, {
    title = "Neovim IDE",
    timeout = 5000,
  })

  collectgarbage("collect")

  log(string.format("Neovim IDE v6.1 ready in %.1fms", startup_time), log_levels.INFO)
end, 1000)

vim.api.nvim_create_autocmd("VimLeavePre", {
  callback = function()
    if theme_timer then
      pcall(function()
        theme_timer:stop()
        theme_timer:close()
      end)
    end
  end,
})

-- =====================================================
-- END OF NEOVIM IDE CONFIGURATION v6.1 (OPTIMIZED)
-- =====================================================

--[[
═══════════════════════════════════════════════════════════════════════
INSTALLATION GUIDE FOR OPENSUSE LEAP + KDE PLASMA
═══════════════════════════════════════════════════════════════════════

1. SYSTEM DEPENDENCIES
   -------------------
   sudo zypper install -y \
     neovim git gcc make cmake \
     ripgrep fd \
     wl-clipboard xclip \
     nodejs npm \
     python3 python3-pip \
     gcc-fortran \
     java-17-openjdk-devel maven

2. PYTHON TOOLS
   ------------
   pip3 install --user \
     black isort flake8 \
     fprettify \
     sqlfluff sqlfmt \
     vsg

3. NODE.JS TOOLS
   -------------
   npm install -g \
     sql-formatter \
     prettier \
     eslint \
     typescript-language-server

4. RUST TOOLCHAIN
   --------------
   curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
   rustup component add clippy rust-analyzer

5. DEPLOY CONFIGURATION
   --------------------
   mkdir -p ~/.config/nvim
   # Copy this file to: ~/.config/nvim/init.lua
   
6. FIRST LAUNCH
   ------------
   nvim
   # Lazy.nvim will auto-install all plugins
   # Wait for completion, then restart

7. INSTALL LSP SERVERS & DEBUGGERS
   --------------------------------
   :Mason
   # Install (press 'i' on each):
   # - debugpy (Python debugger)
   # - pyright, rust-analyzer, lua-ls, etc.
   
8. VERIFICATION
   ------------
   :checkhealth          # Neovim health check
   :Health               # IDE status
   :DebugIDE             # Performance metrics

═══════════════════════════════════════════════════════════════════════
CONFIGURATION OPTIONS
═══════════════════════════════════════════════════════════════════════

Environment Variables:
  NVIM_SECURITY=1     Enable security mode (disables external providers)
  NVIM_DEBUG=1        Enable debug logging
  NVIM_PROFILE=low    Reduce memory limit to 512MB

Project-Specific Config:
  .fortls             Fortran LSP settings (fortls documentation)
  .vhdl_ls.toml       VHDL LSP settings
  .null-ls-root       Null-ls formatter root marker

═══════════════════════════════════════════════════════════════════════
KEY MAPPINGS REFERENCE
═══════════════════════════════════════════════════════════════════════

LEADER KEY: <Space>
LOCAL LEADER: ,

File Operations:
  <leader>w        Save file
  <leader>q        Quit
  <leader>e        Toggle file explorer
  <leader>ff       Find files (Telescope)

Navigation:
  <C-h/j/k/l>     Window navigation
  <S-h/l>         Previous/next buffer
  [b / ]b         Buffer navigation
  [d / ]d         Diagnostic navigation

Code Actions:
  K               Hover documentation
  gd              Go to definition
  gr              Go to references
  <leader>ca      Code action
  <leader>rn      Rename symbol
  <leader>cf      Format buffer

Git:
  <leader>gs      Git status
  <leader>hp      Preview hunk
  <leader>hs      Stage hunk
  ]c / [c         Next/previous hunk

Debugging:
  <F5>            Start/continue debugging
  <F10>           Step over
  <F11>           Step into
  <leader>db      Toggle breakpoint

Code Execution:
  <F5>            Run current file
  <leader>rr      Run current file

Theme:
  <leader>tt      Toggle light/dark
  <leader>td      Solarized dark
  <leader>tl      Solarized light

═══════════════════════════════════════════════════════════════════════
CUSTOM COMMANDS
═══════════════════════════════════════════════════════════════════════

:Health               Show IDE health and configuration status
:DebugIDE             Show performance metrics and plugin load times
:Format               Format buffer or visual selection
:ProjectRoot          Change to project root directory
:CleanUp              Run garbage collection and clear caches
:SolarizedDark        Switch to dark theme (manual)
:SolarizedLight       Switch to light theme (manual)
:EnableAutoTheme      Re-enable automatic theme switching

═══════════════════════════════════════════════════════════════════════
LANGUAGE-SPECIFIC NOTES
═══════════════════════════════════════════════════════════════════════

FORTRAN:
  - Create .fortls config for project-specific preprocessor defines
  - Formatter: fprettify (pip3 install --user fprettify)
  - Color column at 72 and 132 characters

VHDL:
  - No official tree-sitter parser (manual install required)
  - LSP: vhdl_ls (requires .vhdl_ls.toml in project root)
  - Formatter: vsg recommended (pip3 install --user vsg)
  - Use external formatting until none-ls support improves

RUST:
  - Single-file mode warns about external crates
  - Use Cargo.toml for projects with dependencies
  - Debugger: codelldb (install via Mason or system package)

JAVA:
  - Auto-detects Maven/Gradle projects
  - Searches for lib/ directories for classpath
  - JDTLS requires JDK 17+

PYTHON:
  - Debugger: debugpy (install via :MasonInstall debugpy)
  - Formatters: black, isort (auto-run on save)
  - Type checking: pyright LSP

SQL:
  - Multiple formatters supported (sql-formatter, sqlfluff, sqlfmt)
  - Default dialect: PostgreSQL (change in null-ls config)

═══════════════════════════════════════════════════════════════════════
TROUBLESHOOTING
═══════════════════════════════════════════════════════════════════════

Clipboard not working:
  # Wayland (KDE Plasma on Wayland):
  sudo zypper install wl-clipboard
  
  # X11 (fallback):
  sudo zypper install xclip xsel

LSP server not starting:
  :LspInfo              # Check server status
  :Mason                # Verify installation
  :MasonLog             # Check error logs

Slow startup:
  :DebugIDE             # Check plugin load times
  :Lazy profile         # Profile all plugins

Memory leaks:
  :DebugIDE             # Monitor memory usage
  :CleanUp              # Force garbage collection

Python debugger fails:
  :MasonInstall debugpy # Install via Mason first
  # Or fallback: pip3 install --user debugpy

Rust single-file compilation fails:
  # Create Cargo.toml for projects with external dependencies
  # Single files only support std library

VHDL formatting unavailable:
  # Install vsg: pip3 install --user vsg
  # Format externally: vsg -f input.vhd -o output.vhd

═══════════════════════════════════════════════════════════════════════
KNOWN LIMITATIONS
═══════════════════════════════════════════════════════════════════════

1. VHDL tree-sitter parser not officially available
2. VHDL none-ls formatter requires manual setup (vsg recommended)
3. Rust single-file mode cannot handle external crates
4. Java classpath detection limited to standard layouts
5. Fortran preprocessor defines require per-project .fortls config

═══════════════════════════════════════════════════════════════════════
PERFORMANCE OPTIMIZATION
═══════════════════════════════════════════════════════════════════════

Memory Management:
  - Auto garbage collection when >1024MB (configurable)
  - Module caching reduces redundant requires
  - Project root caching prevents repeated FS searches

Startup Optimization:
  - Lazy loading for all non-critical plugins
  - Treesitter on-demand parsing
  - LSP servers start on file open only

Monitoring:
  - Use :DebugIDE every 30 minutes during heavy use
  - Run :CleanUp if memory >800MB
  - Check :Lazy profile for slow plugins

═══════════════════════════════════════════════════════════════════════
]]